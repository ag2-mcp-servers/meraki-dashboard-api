# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T05:04:12+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, RootModel


class DevicesSerialCameraAnalyticsLiveGetResponse(BaseModel):
    pass


class ObjectType(Enum):
    person = 'person'
    vehicle = 'vehicle'


class DevicesSerialCameraAnalyticsOverviewGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class DevicesSerialCameraAnalyticsRecentGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class DevicesSerialCameraAnalyticsZonesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class DevicesSerialCameraAnalyticsZonesZoneIdHistoryGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class DevicesSerialCameraQualityAndRetentionSettingsGetResponse(BaseModel):
    pass


class MotionDetectorVersion(Enum):
    integer_1 = 1
    integer_2 = 2


class Quality(Enum):
    Enhanced = 'Enhanced'
    High = 'High'
    Standard = 'Standard'


class Resolution(Enum):
    field_1080x1080 = '1080x1080'
    field_1280x720 = '1280x720'
    field_1920x1080 = '1920x1080'
    field_2058x2058 = '2058x2058'


class DevicesSerialCameraQualityAndRetentionSettingsPutRequest(BaseModel):
    audioRecordingEnabled: Optional[bool] = Field(
        None,
        description='Boolean indicating if audio recording is enabled(true) or disabled(false) on the camera',
    )
    motionBasedRetentionEnabled: Optional[bool] = Field(
        None,
        description='Boolean indicating if motion-based retention is enabled(true) or disabled(false) on the camera',
    )
    motionDetectorVersion: Optional[MotionDetectorVersion] = Field(
        None,
        description='The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.',
    )
    profileId: Optional[str] = Field(
        None,
        description="The ID of a quality and retention profile to assign to the camera. The profile's settings will override all of the per-camera quality and retention settings. If the value of this parameter is null, any existing profile will be unassigned from the camera.",
    )
    quality: Optional[Quality] = Field(
        None,
        description="Quality of the camera. Can be one of 'Standard', 'High' or 'Enhanced'. Not all qualities are supported by every camera model.",
    )
    resolution: Optional[Resolution] = Field(
        None,
        description="Resolution of the camera. Can be one of '1280x720', '1920x1080', '1080x1080' or '2058x2058'. Not all resolutions are supported by every camera model.",
    )
    restrictedBandwidthModeEnabled: Optional[bool] = Field(
        None,
        description='Boolean indicating if restricted bandwidth is enabled(true) or disabled(false) on the camera. This setting does not apply to MV2 cameras.',
    )


class DevicesSerialCameraQualityAndRetentionSettingsPutResponse(BaseModel):
    pass


class DevicesSerialCameraVideoSettingsGetResponse(BaseModel):
    pass


class DevicesSerialCameraVideoSettingsPutRequest(BaseModel):
    externalRtspEnabled: Optional[bool] = Field(
        None, description='Boolean indicating if external rtsp stream is exposed'
    )


class DevicesSerialCameraVideoSettingsPutResponse(BaseModel):
    pass


class DevicesSerialCellularGatewaySettingsGetResponse(BaseModel):
    pass


class FixedIpAssignment(BaseModel):
    ip: str = Field(
        ...,
        description='The IP address you want to assign to a specific server or device',
    )
    mac: str = Field(
        ...,
        description='The MAC address of the server or device that hosts the internal resource that you wish to receive the specified IP address',
    )
    name: Optional[str] = Field(
        None, description='A descriptive name of the assignment'
    )


class ReservedIpRange(BaseModel):
    comment: str = Field(..., description='Comment explaining the reserved IP range')
    end: str = Field(..., description='Ending IP included in the reserved range of IPs')
    start: str = Field(
        ..., description='Starting IP included in the reserved range of IPs'
    )


class DevicesSerialCellularGatewaySettingsPutRequest(BaseModel):
    fixedIpAssignments: Optional[List[FixedIpAssignment]] = Field(
        None, description='list of all fixed IP assignments for a single MG'
    )
    reservedIpRanges: Optional[List[ReservedIpRange]] = Field(
        None, description='list of all reserved IP ranges for a single MG'
    )


class DevicesSerialCellularGatewaySettingsPutResponse(BaseModel):
    pass


class DevicesSerialCellularGatewaySettingsPortForwardingRulesGetResponse(BaseModel):
    pass


class Rule(BaseModel):
    access: str = Field(
        ...,
        description='`any` or `restricted`. Specify the right to make inbound connections on the specified ports or port ranges. If `restricted`, a list of allowed IPs is mandatory.',
    )
    allowedIps: Optional[List[str]] = Field(
        None,
        description='An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges.',
    )
    lanIp: str = Field(
        ...,
        description='The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN',
    )
    localPort: str = Field(
        ...,
        description='A port or port ranges that will receive the forwarded traffic from the WAN',
    )
    name: Optional[str] = Field(None, description='A descriptive name for the rule')
    protocol: str = Field(..., description='TCP or UDP')
    publicPort: str = Field(
        ...,
        description='A port or port ranges that will be forwarded to the host on the LAN',
    )


class DevicesSerialCellularGatewaySettingsPortForwardingRulesPutRequest(BaseModel):
    rules: Optional[List[Rule]] = Field(
        None, description='An array of port forwarding params'
    )


class DevicesSerialCellularGatewaySettingsPortForwardingRulesPutResponse(BaseModel):
    pass


class DevicesSerialClientsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class DevicesSerialSwitchPortsCyclePostRequest(BaseModel):
    ports: List[str] = Field(
        ...,
        description='List of switch ports. Example: [1, 2-5, 1_MA-MOD-8X10G_1, 1_MA-MOD-8X10G_2-1_MA-MOD-8X10G_8]',
    )


class DevicesSerialSwitchPortsCyclePostResponse(BaseModel):
    pass


class DevicesSerialSwitchPortStatusesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class DevicesSerialSwitchPortStatusesPacketsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class DevicesSerialWirelessBluetoothSettingsPutRequest(BaseModel):
    major: Optional[int] = Field(
        None,
        description="Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.",
    )
    minor: Optional[int] = Field(
        None,
        description="Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.",
    )
    uuid: Optional[str] = Field(
        None,
        description="Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.",
    )


class DevicesSerialWirelessBluetoothSettingsPutResponse(BaseModel):
    major: Optional[int] = Field(
        None,
        description="Desired major value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.",
    )
    minor: Optional[int] = Field(
        None,
        description="Desired minor value of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.",
    )
    uuid: Optional[str] = Field(
        None,
        description="Desired UUID of the beacon. If the value is set to null it will reset to Dashboard's automatically generated value.",
    )


class NetworksNetworkIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdPutRequest(BaseModel):
    disableMyMerakiCom: Optional[bool] = Field(
        None,
        description="Disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)",
    )
    disableRemoteStatusPage: Optional[bool] = Field(
        None,
        description="Disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if disableMyMerakiCom is set to false",
    )
    enrollmentString: Optional[str] = Field(
        None,
        description='A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break.',
    )
    name: Optional[str] = Field(None, description='The name of the network')
    tags: Optional[str] = Field(
        None, description='A space-separated list of tags to be applied to the network'
    )
    timeZone: Optional[str] = Field(
        None,
        description="The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>",
    )


class NetworksNetworkIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdAccessPoliciesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdAirMarshalGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdAlertSettingsGetResponse(BaseModel):
    pass


class AlertDestinations(BaseModel):
    allAdmins: Optional[bool] = Field(
        None,
        description='If true, then all network admins will receive emails for this alert',
    )
    emails: Optional[List[str]] = Field(
        None,
        description='A list of emails that will receive information about the alert',
    )
    httpServerIds: Optional[List[str]] = Field(
        None,
        description='A list of HTTP server IDs to send a Webhook to for this alert',
    )
    snmp: Optional[bool] = Field(
        None,
        description='If true, then an SNMP trap will be sent for this alert if there is an SNMP trap server configured for this network',
    )


class Alert(BaseModel):
    alertDestinations: Optional[AlertDestinations] = Field(
        None, description='A hash of destinations for this specific alert'
    )
    enabled: Optional[bool] = Field(
        None, description='A boolean depicting if the alert is turned on or off'
    )
    filters: Optional[Dict[str, Any]] = Field(
        None,
        description='A hash of specific configuration data for the alert. Only filters specific to the alert will be updated.',
    )
    type: str = Field(..., description='The type of alert')


class DefaultDestinations(BaseModel):
    allAdmins: Optional[bool] = Field(
        None, description='If true, then all network admins will receive emails.'
    )
    emails: Optional[List[str]] = Field(
        None, description='A list of emails that will recieve the alert(s).'
    )
    httpServerIds: Optional[List[str]] = Field(
        None, description='A list of HTTP server IDs to send a Webhook to'
    )
    snmp: Optional[bool] = Field(
        None,
        description='If true, then an SNMP trap will be sent if there is an SNMP trap server configured for this network.',
    )


class NetworksNetworkIdAlertSettingsPutRequest(BaseModel):
    alerts: Optional[List[Alert]] = Field(
        None,
        description='Alert-specific configuration for each type. Only alerts that pertain to the network can be updated.',
    )
    defaultDestinations: Optional[DefaultDestinations] = Field(
        None, description='The network-wide destinations for all alerts on the network.'
    )


class NetworksNetworkIdAlertSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdApplianceFirewallInboundFirewallRulesGetResponse(BaseModel):
    pass


class Policy(Enum):
    allow = 'allow'
    deny = 'deny'


class Protocol(Enum):
    any = 'any'
    icmp = 'icmp'
    icmp6 = 'icmp6'
    tcp = 'tcp'
    udp = 'udp'


class Rule1(BaseModel):
    comment: Optional[str] = Field(
        None, description='Description of the rule (optional)'
    )
    destCidr: str = Field(
        ...,
        description="Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'",
    )
    destPort: Optional[str] = Field(
        None,
        description="Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'",
    )
    policy: Policy = Field(
        ..., description="'allow' or 'deny' traffic specified by this rule"
    )
    protocol: Protocol = Field(
        ...,
        description="The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')",
    )
    srcCidr: str = Field(
        ...,
        description="Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)",
    )
    srcPort: Optional[str] = Field(
        None,
        description="Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'",
    )
    syslogEnabled: Optional[bool] = Field(
        None,
        description='Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)',
    )


class NetworksNetworkIdApplianceFirewallInboundFirewallRulesPutRequest(BaseModel):
    rules: Optional[List[Rule1]] = Field(
        None,
        description='An ordered array of the firewall rules (not including the default rule)',
    )
    syslogDefaultRule: Optional[bool] = Field(
        None,
        description="Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)",
    )


class NetworksNetworkIdApplianceFirewallInboundFirewallRulesPutResponse(BaseModel):
    pass


class NetworksNetworkIdAppliancePortsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdAppliancePortsAppliancePortIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdAppliancePortsAppliancePortIdPutRequest(BaseModel):
    accessPolicy: Optional[str] = Field(
        None,
        description="The name of the policy. Only applicable to Access ports. Valid values are: 'open', '8021x-radius', 'mac-radius', 'hybris-radius' for MX64 or Z3 or any MX supporting the per port authentication feature. Otherwise, 'open' is the only valid value and 'open' is the default value if the field is missing.",
    )
    allowedVlans: Optional[str] = Field(
        None,
        description="Comma-delimited list of the VLAN ID's allowed on the port, or 'all' to permit all VLAN's on the port.",
    )
    dropUntaggedTraffic: Optional[bool] = Field(
        None,
        description='Trunk port can Drop all Untagged traffic. When true, no VLAN is required. Access ports cannot have dropUntaggedTraffic set to true.',
    )
    enabled: Optional[bool] = Field(None, description='The status of the port')
    type: Optional[str] = Field(
        None, description="The type of the port: 'access' or 'trunk'."
    )
    vlan: Optional[int] = Field(
        None,
        description='Native VLAN when the port is in Trunk mode. Access VLAN when the port is in Access mode.',
    )


class NetworksNetworkIdAppliancePortsAppliancePortIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdBindPostRequest(BaseModel):
    autoBind: Optional[bool] = Field(
        None,
        description="Optional boolean indicating whether the network's switches should automatically bind to profiles of the same model. Defaults to false if left unspecified. This option only affects switch networks and switch templates. Auto-bind is not valid unless the switch template has at least one profile and has at most one profile per switch model.",
    )
    configTemplateId: str = Field(
        ..., description='The ID of the template to which the network should be bound.'
    )


class NetworksNetworkIdBluetoothClientsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdBluetoothClientsBluetoothClientIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdBluetoothSettingsGetResponse(BaseModel):
    advertisingEnabled: Optional[bool] = Field(
        None, description='Whether APs will advertise beacons.'
    )
    major: Optional[int] = Field(
        None,
        description="The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.",
    )
    majorMinorAssignmentMode: Optional[str] = Field(
        None,
        description="The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')",
    )
    minor: Optional[int] = Field(
        None,
        description="The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.",
    )
    scanningEnabled: Optional[bool] = Field(
        None, description='Whether APs will scan for Bluetooth enabled clients.'
    )
    uuid: Optional[str] = Field(
        None, description='The UUID to be used in the beacon identifier.'
    )


class MajorMinorAssignmentMode(Enum):
    Non_unique = 'Non-unique'
    Unique = 'Unique'


class NetworksNetworkIdBluetoothSettingsPutRequest(BaseModel):
    advertisingEnabled: Optional[bool] = Field(
        None, description='Whether APs will advertise beacons.'
    )
    major: Optional[int] = Field(
        None,
        description="The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.",
    )
    majorMinorAssignmentMode: Optional[MajorMinorAssignmentMode] = Field(
        None,
        description="The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')",
    )
    minor: Optional[int] = Field(
        None,
        description="The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.",
    )
    scanningEnabled: Optional[bool] = Field(
        None, description='Whether APs will scan for Bluetooth enabled clients.'
    )
    uuid: Optional[str] = Field(
        None, description='The UUID to be used in the beacon identifier.'
    )


class NetworksNetworkIdBluetoothSettingsPutResponse(BaseModel):
    advertisingEnabled: Optional[bool] = Field(
        None, description='Whether APs will advertise beacons.'
    )
    major: Optional[int] = Field(
        None,
        description="The major number to be used in the beacon identifier. Only valid in 'Non-unique' mode.",
    )
    majorMinorAssignmentMode: Optional[str] = Field(
        None,
        description="The way major and minor number should be assigned to nodes in the network. ('Unique', 'Non-unique')",
    )
    minor: Optional[int] = Field(
        None,
        description="The minor number to be used in the beacon identifier. Only valid in 'Non-unique' mode.",
    )
    scanningEnabled: Optional[bool] = Field(
        None, description='Whether APs will scan for Bluetooth enabled clients.'
    )
    uuid: Optional[str] = Field(
        None, description='The UUID to be used in the beacon identifier.'
    )


class NetworksNetworkIdCameraQualityRetentionProfilesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Resolution1(Enum):
    field_1280x720 = '1280x720'
    field_1920x1080 = '1920x1080'


class MV12MV22MV72(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution1 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720' or '1920x1080'.",
    )


class MV12WE(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution1 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720' or '1920x1080'.",
    )


class Resolution3(Enum):
    field_1080x1080 = '1080x1080'
    field_2688x1512 = '2688x1512'


class MV13(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution3 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.",
    )


class Resolution4(Enum):
    field_1280x720 = '1280x720'


class MV21MV71(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution4 = Field(
        ..., description="Resolution of the camera. Can be one of '1280x720'."
    )


class Resolution5(Enum):
    field_1280x720 = '1280x720'
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'


class MV22XMV72X(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution5 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.",
    )


class Resolution6(Enum):
    field_1080x1080 = '1080x1080'
    field_2058x2058 = '2058x2058'


class MV32(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution6 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.",
    )


class Resolution7(Enum):
    field_1080x1080 = '1080x1080'
    field_2112x2112 = '2112x2112'


class MV33(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution7 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.",
    )


class Resolution8(Enum):
    field_1280x720 = '1280x720'
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'
    field_3840x2160 = '3840x2160'


class MV52(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution8 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.",
    )


class Resolution9(Enum):
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'


class MV63(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution9 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.",
    )


class Resolution10(Enum):
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'
    field_3840x2160 = '3840x2160'


class MV63X(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution10 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.",
    )


class Resolution11(Enum):
    field_1080x1080 = '1080x1080'
    field_2112x2112 = '2112x2112'


class MV93(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution11 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.",
    )


class Resolution12(Enum):
    field_1080x1080 = '1080x1080'
    field_2112x2112 = '2112x2112'
    field_2880x2880 = '2880x2880'


class MV93X(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution12 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.",
    )


class VideoSettings(BaseModel):
    MV12_MV22_MV72: Optional[MV12MV22MV72] = Field(
        None,
        alias='MV12/MV22/MV72',
        description='Quality and resolution for MV12/MV22/MV72 camera models.',
    )
    MV12WE_1: Optional[MV12WE] = Field(
        None,
        alias='MV12WE',
        description='Quality and resolution for MV12WE camera models.',
    )
    MV13_1: Optional[MV13] = Field(
        None, alias='MV13', description='Quality and resolution for MV13 camera models.'
    )
    MV21_MV71: Optional[MV21MV71] = Field(
        None,
        alias='MV21/MV71',
        description='Quality and resolution for MV21/MV71 camera models.',
    )
    MV22X_MV72X: Optional[MV22XMV72X] = Field(
        None,
        alias='MV22X/MV72X',
        description='Quality and resolution for MV22X/MV72X camera models.',
    )
    MV32_1: Optional[MV32] = Field(
        None, alias='MV32', description='Quality and resolution for MV32 camera models.'
    )
    MV33_1: Optional[MV33] = Field(
        None, alias='MV33', description='Quality and resolution for MV33 camera models.'
    )
    MV52_1: Optional[MV52] = Field(
        None, alias='MV52', description='Quality and resolution for MV52 camera models.'
    )
    MV63_1: Optional[MV63] = Field(
        None, alias='MV63', description='Quality and resolution for MV63 camera models.'
    )
    MV63X_1: Optional[MV63X] = Field(
        None,
        alias='MV63X',
        description='Quality and resolution for MV63X camera models.',
    )
    MV93_1: Optional[MV93] = Field(
        None, alias='MV93', description='Quality and resolution for MV93 camera models.'
    )
    MV93X_1: Optional[MV93X] = Field(
        None,
        alias='MV93X',
        description='Quality and resolution for MV93X camera models.',
    )


class NetworksNetworkIdCameraQualityRetentionProfilesPostRequest(BaseModel):
    audioRecordingEnabled: Optional[bool] = Field(
        None,
        description='Whether or not to record audio. Can be either true or false. Defaults to false.',
    )
    cloudArchiveEnabled: Optional[bool] = Field(
        None,
        description='Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.',
    )
    maxRetentionDays: Optional[int] = Field(
        None,
        description="The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days.",
    )
    motionBasedRetentionEnabled: Optional[bool] = Field(
        None,
        description='Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.',
    )
    motionDetectorVersion: Optional[int] = Field(
        None,
        description='The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.',
    )
    name: str = Field(
        ...,
        description='The name of the new profile. Must be unique. This parameter is required.',
    )
    restrictedBandwidthModeEnabled: Optional[bool] = Field(
        None,
        description='Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.',
    )
    scheduleId: Optional[str] = Field(
        None,
        description="Schedule for which this camera will record video, or 'null' to always record.",
    )
    videoSettings: Optional[VideoSettings] = Field(
        None,
        description='Video quality and resolution settings for all the camera models.',
    )


class NetworksNetworkIdCameraQualityRetentionProfilesPostResponse(BaseModel):
    pass


class NetworksNetworkIdCameraQualityRetentionProfilesQualityRetentionProfileIdGetResponse(
    BaseModel
):
    pass


class Resolution13(Enum):
    field_1280x720 = '1280x720'
    field_1920x1080 = '1920x1080'


class MV12MV22MV721(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution13 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720' or '1920x1080'.",
    )


class MV12WE1(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution13 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720' or '1920x1080'.",
    )


class Resolution15(Enum):
    field_1080x1080 = '1080x1080'
    field_2688x1512 = '2688x1512'


class MV131(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution15 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2688x1512'.",
    )


class Resolution16(Enum):
    field_1280x720 = '1280x720'


class MV21MV711(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution16 = Field(
        ..., description="Resolution of the camera. Can be one of '1280x720'."
    )


class Resolution17(Enum):
    field_1280x720 = '1280x720'
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'


class MV22XMV72X1(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution17 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720', '1920x1080' or '2688x1512'.",
    )


class Resolution18(Enum):
    field_1080x1080 = '1080x1080'
    field_2058x2058 = '2058x2058'


class MV321(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution18 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2058x2058'.",
    )


class Resolution19(Enum):
    field_1080x1080 = '1080x1080'
    field_2112x2112 = '2112x2112'


class MV331(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution19 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.",
    )


class Resolution20(Enum):
    field_1280x720 = '1280x720'
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'
    field_3840x2160 = '3840x2160'


class MV521(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution20 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1280x720', '1920x1080', '2688x1512' or '3840x2160'.",
    )


class Resolution21(Enum):
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'


class MV631(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution21 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1920x1080' or '2688x1512'.",
    )


class Resolution22(Enum):
    field_1920x1080 = '1920x1080'
    field_2688x1512 = '2688x1512'
    field_3840x2160 = '3840x2160'


class MV63X1(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution22 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1920x1080', '2688x1512' or '3840x2160'.",
    )


class Resolution23(Enum):
    field_1080x1080 = '1080x1080'
    field_2112x2112 = '2112x2112'


class MV931(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution23 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080' or '2112x2112'.",
    )


class Resolution24(Enum):
    field_1080x1080 = '1080x1080'
    field_2112x2112 = '2112x2112'
    field_2880x2880 = '2880x2880'


class MV93X1(BaseModel):
    quality: Quality = Field(
        ...,
        description="Quality of the camera. Can be one of 'Standard', 'Enhanced' or 'High'.",
    )
    resolution: Resolution24 = Field(
        ...,
        description="Resolution of the camera. Can be one of '1080x1080', '2112x2112' or '2880x2880'.",
    )


class VideoSettings1(BaseModel):
    MV12_MV22_MV72: Optional[MV12MV22MV721] = Field(
        None,
        alias='MV12/MV22/MV72',
        description='Quality and resolution for MV12/MV22/MV72 camera models.',
    )
    MV12WE: Optional[MV12WE1] = Field(
        None, description='Quality and resolution for MV12WE camera models.'
    )
    MV13: Optional[MV131] = Field(
        None, description='Quality and resolution for MV13 camera models.'
    )
    MV21_MV71: Optional[MV21MV711] = Field(
        None,
        alias='MV21/MV71',
        description='Quality and resolution for MV21/MV71 camera models.',
    )
    MV22X_MV72X: Optional[MV22XMV72X1] = Field(
        None,
        alias='MV22X/MV72X',
        description='Quality and resolution for MV22X/MV72X camera models.',
    )
    MV32: Optional[MV321] = Field(
        None, description='Quality and resolution for MV32 camera models.'
    )
    MV33: Optional[MV331] = Field(
        None, description='Quality and resolution for MV33 camera models.'
    )
    MV52: Optional[MV521] = Field(
        None, description='Quality and resolution for MV52 camera models.'
    )
    MV63: Optional[MV631] = Field(
        None, description='Quality and resolution for MV63 camera models.'
    )
    MV63X: Optional[MV63X1] = Field(
        None, description='Quality and resolution for MV63X camera models.'
    )
    MV93: Optional[MV931] = Field(
        None, description='Quality and resolution for MV93 camera models.'
    )
    MV93X: Optional[MV93X1] = Field(
        None, description='Quality and resolution for MV93X camera models.'
    )


class NetworksNetworkIdCameraQualityRetentionProfilesQualityRetentionProfileIdPutRequest(
    BaseModel
):
    audioRecordingEnabled: Optional[bool] = Field(
        None,
        description='Whether or not to record audio. Can be either true or false. Defaults to false.',
    )
    cloudArchiveEnabled: Optional[bool] = Field(
        None,
        description='Create redundant video backup using Cloud Archive. Can be either true or false. Defaults to false.',
    )
    maxRetentionDays: Optional[int] = Field(
        None,
        description="The maximum number of days for which the data will be stored, or 'null' to keep data until storage space runs out. If the former, it can be one of [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 30, 60, 90] days.",
    )
    motionBasedRetentionEnabled: Optional[bool] = Field(
        None,
        description='Deletes footage older than 3 days in which no motion was detected. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.',
    )
    motionDetectorVersion: Optional[int] = Field(
        None,
        description='The version of the motion detector that will be used by the camera. Only applies to Gen 2 cameras. Defaults to v2.',
    )
    name: Optional[str] = Field(
        None, description='The name of the new profile. Must be unique.'
    )
    restrictedBandwidthModeEnabled: Optional[bool] = Field(
        None,
        description='Disable features that require additional bandwidth such as Motion Recap. Can be either true or false. Defaults to false. This setting does not apply to MV2 cameras.',
    )
    scheduleId: Optional[str] = Field(
        None,
        description="Schedule for which this camera will record video, or 'null' to always record.",
    )
    videoSettings: Optional[VideoSettings1] = Field(
        None,
        description='Video quality and resolution settings for all the camera models.',
    )


class NetworksNetworkIdCameraQualityRetentionProfilesQualityRetentionProfileIdPutResponse(
    BaseModel
):
    pass


class NetworksNetworkIdCameraSchedulesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdCamerasSerialSnapshotPostRequest(BaseModel):
    fullframe: Optional[bool] = Field(
        None,
        description='[optional] If set to "true" the snapshot will be taken at full sensor resolution. This will error if used with timestamp.',
    )
    timestamp: Optional[datetime] = Field(
        None,
        description='[optional] The snapshot will be taken from this time on the camera. The timestamp is expected to be in ISO 8601 format. If no timestamp is specified, we will assume current time.',
    )


class NetworksNetworkIdCamerasSerialSnapshotPostResponse(BaseModel):
    pass


class NetworksNetworkIdCamerasSerialVideoLinkGetResponse(BaseModel):
    pass


class NetworksNetworkIdCellularFirewallRulesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Rule2(BaseModel):
    comment: Optional[str] = Field(
        None, description='Description of the rule (optional)'
    )
    destCidr: str = Field(
        ...,
        description="Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'",
    )
    destPort: Optional[str] = Field(
        None,
        description="Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'",
    )
    policy: Policy = Field(
        ..., description="'allow' or 'deny' traffic specified by this rule"
    )
    protocol: Protocol = Field(
        ...,
        description="The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')",
    )
    srcCidr: str = Field(
        ...,
        description="Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)",
    )
    srcPort: Optional[str] = Field(
        None,
        description="Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'",
    )
    syslogEnabled: Optional[bool] = Field(
        None,
        description='Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)',
    )


class NetworksNetworkIdCellularFirewallRulesPutRequest(BaseModel):
    rules: Optional[List[Rule2]] = Field(
        None,
        description='An ordered array of the firewall rules (not including the default rule)',
    )


class NetworksNetworkIdCellularFirewallRulesPutResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Status(Enum):
    Offline = 'Offline'
    Online = 'Online'


class Usage(BaseModel):
    recv: Optional[float] = Field(None, description='Usage received by the client')
    sent: Optional[float] = Field(None, description='Usage sent by the client')


class NetworksNetworkIdClientsGetResponse(BaseModel):
    description: Optional[str] = Field(
        None, description='Short description of the client'
    )
    firstSeen: Optional[int] = Field(
        None, description='Timestamp client was first seen in the network'
    )
    groupPolicy8021x: Optional[str] = Field(
        None, description='802.1x group policy of the client'
    )
    id: Optional[str] = Field(None, description='The ID of the client')
    ip: Optional[str] = Field(None, description='The IP address of the client')
    ip6: Optional[str] = Field(None, description='The IPv6 address of the client')
    ip6Local: Optional[str] = Field(
        None, description='Local IPv6 address of the client'
    )
    lastSeen: Optional[int] = Field(
        None, description='Timestamp client was last seen in the network'
    )
    mac: Optional[str] = Field(None, description='The MAC address of the client')
    manufacturer: Optional[str] = Field(None, description='Manufacturer of the client')
    notes: Optional[str] = Field(None, description='Notes on the client')
    os: Optional[str] = Field(None, description='The operating system of the client')
    recentDeviceMac: Optional[str] = Field(
        None,
        description='The MAC address of the node that the device was last connected to',
    )
    recentDeviceName: Optional[str] = Field(
        None, description='The name of the node the device was last connected to'
    )
    recentDeviceSerial: Optional[str] = Field(
        None, description='The serial of the node the device was last connected to'
    )
    smInstalled: Optional[bool] = Field(None, description='Status of SM for the client')
    ssid: Optional[str] = Field(
        None, description='The name of the SSID that the client is connected to'
    )
    status: Optional[Status] = Field(
        None, description='The connection status of the client'
    )
    switchport: Optional[str] = Field(
        None, description='The switch port that the client is connected to'
    )
    usage: Optional[Usage] = Field(None, description='Usage, sent and received')
    user: Optional[str] = Field(
        None, description='The username of the user of the client'
    )
    vlan: Optional[str] = Field(
        None, description='The name of the VLAN that the client is connected to'
    )


class Band(Enum):
    field_2_4 = '2.4'
    field_5 = '5'


class NetworksNetworkIdClientsConnectionStatsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdClientsLatencyStatsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class DevicePolicy(Enum):
    Allowed = 'Allowed'
    Blocked = 'Blocked'
    Group_policy = 'Group policy'
    Normal = 'Normal'
    Per_connection = 'Per connection'
    Whitelisted = 'Whitelisted'


class DevicePolicy1(Enum):
    Blocked = 'Blocked'
    Normal = 'Normal'
    Whitelisted = 'Whitelisted'


class PoliciesBySecurityAppliance(BaseModel):
    devicePolicy: Optional[DevicePolicy1] = Field(
        None,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked' or 'Normal'. Required.",
    )


class DevicePolicy2(Enum):
    Blocked = 'Blocked'
    Group_policy = 'Group policy'
    Normal = 'Normal'
    Whitelisted = 'Whitelisted'


class Field0(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field1(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field10(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field11(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field12(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field13(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field14(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field2(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field3(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field4(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field5(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field6(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field7(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field8(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class Field9(BaseModel):
    devicePolicy: DevicePolicy2 = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )


class PoliciesBySsid(BaseModel):
    field_0: Optional[Field0] = Field(
        None, alias='0', description='The number for the SSID'
    )
    field_1: Optional[Field1] = Field(
        None, alias='1', description='The number for the SSID'
    )
    field_10: Optional[Field10] = Field(
        None, alias='10', description='The number for the SSID'
    )
    field_11: Optional[Field11] = Field(
        None, alias='11', description='The number for the SSID'
    )
    field_12: Optional[Field12] = Field(
        None, alias='12', description='The number for the SSID'
    )
    field_13: Optional[Field13] = Field(
        None, alias='13', description='The number for the SSID'
    )
    field_14: Optional[Field14] = Field(
        None, alias='14', description='The number for the SSID'
    )
    field_2: Optional[Field2] = Field(
        None, alias='2', description='The number for the SSID'
    )
    field_3: Optional[Field3] = Field(
        None, alias='3', description='The number for the SSID'
    )
    field_4: Optional[Field4] = Field(
        None, alias='4', description='The number for the SSID'
    )
    field_5: Optional[Field5] = Field(
        None, alias='5', description='The number for the SSID'
    )
    field_6: Optional[Field6] = Field(
        None, alias='6', description='The number for the SSID'
    )
    field_7: Optional[Field7] = Field(
        None, alias='7', description='The number for the SSID'
    )
    field_8: Optional[Field8] = Field(
        None, alias='8', description='The number for the SSID'
    )
    field_9: Optional[Field9] = Field(
        None, alias='9', description='The number for the SSID'
    )


class NetworksNetworkIdClientsProvisionPostRequest(BaseModel):
    devicePolicy: DevicePolicy = Field(
        ...,
        description="The policy to apply to the specified client. Can be 'Group policy', 'Whitelisted', 'Allowed', 'Blocked', 'Per connection' or 'Normal'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description='The ID of the desired group policy to apply to the client. Required if \'devicePolicy\' is set to "Group policy". Otherwise this is ignored.',
    )
    mac: str = Field(..., description='The MAC address of the client. Required.')
    name: Optional[str] = Field(
        None,
        description='The display name for the client. Optional. Limited to 255 bytes.',
    )
    policiesBySecurityAppliance: Optional[PoliciesBySecurityAppliance] = Field(
        None,
        description='An object, describing what the policy-connection association is for the security appliance. (Only relevant if the security appliance is actually within the network)',
    )
    policiesBySsid: Optional[PoliciesBySsid] = Field(
        None,
        description="An object, describing the policy-connection associations for each active SSID within the network. Keys should be the number of enabled SSIDs, mapping to an object describing the client's policy",
    )


class NetworksNetworkIdClientsProvisionPostResponse(BaseModel):
    pass


class NetworksNetworkIdClientsClientIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdClientsClientIdConnectionStatsGetResponse(BaseModel):
    pass


class NetworksNetworkIdClientsClientIdEventsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdClientsClientIdLatencyHistoryGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdClientsClientIdLatencyStatsGetResponse(BaseModel):
    pass


class NetworksNetworkIdClientsClientIdPolicyGetResponse(BaseModel):
    pass


class NetworksNetworkIdClientsClientIdPolicyPutRequest(BaseModel):
    devicePolicy: str = Field(
        ...,
        description="The policy to assign. Can be 'Whitelisted', 'Blocked', 'Normal' or 'Group policy'. Required.",
    )
    groupPolicyId: Optional[str] = Field(
        None,
        description="[optional] If 'devicePolicy' is set to 'Group policy' this param is used to specify the group policy ID.",
    )


class NetworksNetworkIdClientsClientIdPolicyPutResponse(BaseModel):
    pass


class NetworksNetworkIdClientsClientIdSplashAuthorizationStatusGetResponse(BaseModel):
    pass


class Field01(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field15(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field101(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field111(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field121(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field131(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field141(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field21(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field31(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field41(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field51(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field61(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field71(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field81(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Field91(BaseModel):
    isAuthorized: Optional[bool] = Field(
        None, description='New authorization status for the SSID (true, false).'
    )


class Ssids(BaseModel):
    field_0: Optional[Field01] = Field(
        None, alias='0', description='Splash authorization for SSID 0'
    )
    field_1: Optional[Field15] = Field(
        None, alias='1', description='Splash authorization for SSID 1'
    )
    field_10: Optional[Field101] = Field(
        None, alias='10', description='Splash authorization for SSID 10'
    )
    field_11: Optional[Field111] = Field(
        None, alias='11', description='Splash authorization for SSID 11'
    )
    field_12: Optional[Field121] = Field(
        None, alias='12', description='Splash authorization for SSID 12'
    )
    field_13: Optional[Field131] = Field(
        None, alias='13', description='Splash authorization for SSID 13'
    )
    field_14: Optional[Field141] = Field(
        None, alias='14', description='Splash authorization for SSID 14'
    )
    field_2: Optional[Field21] = Field(
        None, alias='2', description='Splash authorization for SSID 2'
    )
    field_3: Optional[Field31] = Field(
        None, alias='3', description='Splash authorization for SSID 3'
    )
    field_4: Optional[Field41] = Field(
        None, alias='4', description='Splash authorization for SSID 4'
    )
    field_5: Optional[Field51] = Field(
        None, alias='5', description='Splash authorization for SSID 5'
    )
    field_6: Optional[Field61] = Field(
        None, alias='6', description='Splash authorization for SSID 6'
    )
    field_7: Optional[Field71] = Field(
        None, alias='7', description='Splash authorization for SSID 7'
    )
    field_8: Optional[Field81] = Field(
        None, alias='8', description='Splash authorization for SSID 8'
    )
    field_9: Optional[Field91] = Field(
        None, alias='9', description='Splash authorization for SSID 9'
    )


class NetworksNetworkIdClientsClientIdSplashAuthorizationStatusPutRequest(BaseModel):
    ssids: Ssids = Field(
        ...,
        description="The target SSIDs. Each SSID must be enabled and must have Click-through splash enabled. For each SSID where isAuthorized is true, the expiration time will automatically be set according to the SSID's splash frequency. Not all networks support configuring all SSIDs",
    )


class NetworksNetworkIdClientsClientIdSplashAuthorizationStatusPutResponse(BaseModel):
    pass


class NetworksNetworkIdClientsClientIdUsageHistoryGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdConnectionStatsGetResponse(BaseModel):
    pass


class NetworksNetworkIdContentFilteringGetResponse(BaseModel):
    pass


class UrlCategoryListSize(Enum):
    fullList = 'fullList'
    topSites = 'topSites'


class NetworksNetworkIdContentFilteringPutRequest(BaseModel):
    allowedUrlPatterns: Optional[List[str]] = Field(
        None, description='A list of URL patterns that are allowed'
    )
    blockedUrlCategories: Optional[List[str]] = Field(
        None, description='A list of URL categories to block'
    )
    blockedUrlPatterns: Optional[List[str]] = Field(
        None, description='A list of URL patterns that are blocked'
    )
    urlCategoryListSize: Optional[UrlCategoryListSize] = Field(
        None,
        description="URL category list size which is either 'topSites' or 'fullList'",
    )


class NetworksNetworkIdContentFilteringPutResponse(BaseModel):
    pass


class NetworksNetworkIdContentFilteringCategoriesGetResponse(BaseModel):
    pass


class NetworksNetworkIdDevicesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdDevicesClaimPostRequest(BaseModel):
    serial: Optional[str] = Field(
        None, description='[DEPRECATED] The serial of a device to claim'
    )
    serials: Optional[List[str]] = Field(
        None, description='A list of serials of devices to claim'
    )


class NetworksNetworkIdDevicesConnectionStatsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdDevicesLatencyStatsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdDevicesSerialGetResponse(BaseModel):
    pass


class NetworksNetworkIdDevicesSerialPutRequest(BaseModel):
    address: Optional[str] = Field(None, description='The address of a device')
    floorPlanId: Optional[str] = Field(
        None,
        description='The floor plan to associate to this device. null disassociates the device from the floorplan.',
    )
    lat: Optional[float] = Field(None, description='The latitude of a device')
    lng: Optional[float] = Field(None, description='The longitude of a device')
    moveMapMarker: Optional[bool] = Field(
        None,
        description='Whether or not to set the latitude and longitude of a device based on the new address. Only applies when lat and lng are not specified.',
    )
    name: Optional[str] = Field(None, description='The name of a device')
    notes: Optional[str] = Field(
        None, description='The notes for the device. String. Limited to 255 characters.'
    )
    switchProfileId: Optional[str] = Field(
        None,
        description="The ID of a switch profile to bind to the device (for available switch profiles, see the 'Switch Profiles' endpoint). Use null to unbind the switch device from the current profile. For a device to be bindable to a switch profile, it must (1) be a switch, and (2) belong to a network that is bound to a configuration template.",
    )
    tags: Optional[str] = Field(None, description='The tags of a device')


class NetworksNetworkIdDevicesSerialPutResponse(BaseModel):
    pass


class NetworksNetworkIdDevicesSerialConnectionStatsGetResponse(BaseModel):
    pass


class NetworksNetworkIdDevicesSerialLatencyStatsGetResponse(BaseModel):
    pass


class Uplink(Enum):
    cellular = 'cellular'
    wan1 = 'wan1'
    wan2 = 'wan2'


class NetworksNetworkIdDevicesSerialLossAndLatencyHistoryGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdDevicesSerialPerformanceGetResponse(BaseModel):
    pass


class NetworksNetworkIdDevicesSerialRebootPostResponse(BaseModel):
    pass


class NetworksNetworkIdDevicesSerialUplinkGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdDevicesSerialWirelessStatusGetResponse(BaseModel):
    pass


class NetworksNetworkIdEventsGetResponse(BaseModel):
    pass


class IncludedEventTypes(RootModel[List[str]]):
    root: List[str]


class ExcludedEventTypes(RootModel[List[str]]):
    root: List[str]


class NetworksNetworkIdEventsEventTypesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdFailedConnectionsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdFirewalledServicesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdFirewalledServicesServiceGetResponse(BaseModel):
    pass


class Access(Enum):
    blocked = 'blocked'
    restricted = 'restricted'
    unrestricted = 'unrestricted'


class NetworksNetworkIdFirewalledServicesServicePutRequest(BaseModel):
    access: Access = Field(
        ...,
        description='A string indicating the rule for which IPs are allowed to use the specified service. Acceptable values are "blocked" (no remote IPs can access the service), "restricted" (only whitelisted IPs can access the service), and "unrestriced" (any remote IP can access the service). This field is required',
    )
    allowedIps: Optional[List[str]] = Field(
        None,
        description='An array of whitelisted IPs that can access the service. This field is required if "access" is set to "restricted". Otherwise this field is ignored',
    )


class NetworksNetworkIdFirewalledServicesServicePutResponse(BaseModel):
    pass


class NetworksNetworkIdFloorPlansGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class BottomLeftCorner(BaseModel):
    lat: Optional[float] = Field(None, description='Latitude')
    lng: Optional[float] = Field(None, description='Longitude')


class BottomRightCorner(BaseModel):
    lat: Optional[float] = Field(None, description='Latitude')
    lng: Optional[float] = Field(None, description='Longitude')


class Center(BaseModel):
    lat: Optional[float] = Field(None, description='Latitude')
    lng: Optional[float] = Field(None, description='Longitude')


class TopLeftCorner(BaseModel):
    lat: Optional[float] = Field(None, description='Latitude')
    lng: Optional[float] = Field(None, description='Longitude')


class TopRightCorner(BaseModel):
    lat: Optional[float] = Field(None, description='Latitude')
    lng: Optional[float] = Field(None, description='Longitude')


class NetworksNetworkIdFloorPlansPostRequest(BaseModel):
    bottomLeftCorner: Optional[BottomLeftCorner] = Field(
        None,
        description='The longitude and latitude of the bottom left corner of your floor plan.',
    )
    bottomRightCorner: Optional[BottomRightCorner] = Field(
        None,
        description='The longitude and latitude of the bottom right corner of your floor plan.',
    )
    center: Optional[Center] = Field(
        None,
        description="The longitude and latitude of the center of your floor plan. The 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.",
    )
    imageContents: str = Field(
        ...,
        description='The file contents (a base 64 encoded string) of your image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in.',
    )
    name: str = Field(..., description='The name of your floor plan.')
    topLeftCorner: Optional[TopLeftCorner] = Field(
        None,
        description='The longitude and latitude of the top left corner of your floor plan.',
    )
    topRightCorner: Optional[TopRightCorner] = Field(
        None,
        description='The longitude and latitude of the top right corner of your floor plan.',
    )


class NetworksNetworkIdFloorPlansPostResponse(BaseModel):
    pass


class NetworksNetworkIdFloorPlansFloorPlanIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdFloorPlansFloorPlanIdPutRequest(BaseModel):
    bottomLeftCorner: Optional[BottomLeftCorner] = Field(
        None,
        description='The longitude and latitude of the bottom left corner of your floor plan.',
    )
    bottomRightCorner: Optional[BottomRightCorner] = Field(
        None,
        description='The longitude and latitude of the bottom right corner of your floor plan.',
    )
    center: Optional[Center] = Field(
        None,
        description="The longitude and latitude of the center of your floor plan. If you want to change the geolocation data of your floor plan, either the 'center' or two adjacent corners (e.g. 'topLeftCorner' and 'bottomLeftCorner') must be specified. If 'center' is specified, the floor plan is placed over that point with no rotation. If two adjacent corners are specified, the floor plan is rotated to line up with the two specified points. The aspect ratio of the floor plan's image is preserved regardless of which corners/center are specified. (This means if that more than two corners are specified, only two corners may be used to preserve the floor plan's aspect ratio.). No two points can have the same latitude, longitude pair.",
    )
    imageContents: Optional[str] = Field(
        None,
        description="The file contents (a base 64 encoded string) of your new image. Supported formats are PNG, GIF, and JPG. Note that all images are saved as PNG files, regardless of the format they are uploaded in. If you upload a new image, and you do NOT specify any new geolocation fields ('center, 'topLeftCorner', etc), the floor plan will be recentered with no rotation in order to maintain the aspect ratio of your new image.",
    )
    name: Optional[str] = Field(None, description='The name of your floor plan.')
    topLeftCorner: Optional[TopLeftCorner] = Field(
        None,
        description='The longitude and latitude of the top left corner of your floor plan.',
    )
    topRightCorner: Optional[TopRightCorner] = Field(
        None,
        description='The longitude and latitude of the top right corner of your floor plan.',
    )


class NetworksNetworkIdFloorPlansFloorPlanIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdL3FirewallRulesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class Rule3(BaseModel):
    comment: Optional[str] = Field(
        None, description='Description of the rule (optional)'
    )
    destCidr: str = Field(
        ...,
        description="Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'",
    )
    destPort: Optional[str] = Field(
        None,
        description="Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'",
    )
    policy: Policy = Field(
        ..., description="'allow' or 'deny' traffic specified by this rule"
    )
    protocol: Protocol = Field(
        ...,
        description="The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')",
    )
    srcCidr: str = Field(
        ...,
        description="Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (note: FQDN not supported for source addresses)",
    )
    srcPort: Optional[str] = Field(
        None,
        description="Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'",
    )
    syslogEnabled: Optional[bool] = Field(
        None,
        description='Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)',
    )


class NetworksNetworkIdL3FirewallRulesPutRequest(BaseModel):
    rules: Optional[List[Rule3]] = Field(
        None,
        description='An ordered array of the firewall rules (not including the default rule)',
    )
    syslogDefaultRule: Optional[bool] = Field(
        None,
        description="Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)",
    )


class NetworksNetworkIdL3FirewallRulesPutResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdL7FirewallRulesGetResponse(BaseModel):
    pass


class Policy3(Enum):
    deny = 'deny'


class Type(Enum):
    application = 'application'
    applicationCategory = 'applicationCategory'
    host = 'host'
    ipRange = 'ipRange'
    port = 'port'


class Rule4(BaseModel):
    policy: Optional[Policy3] = Field(
        None, description="'Deny' traffic specified by this rule"
    )
    type: Optional[Type] = Field(
        None,
        description="Type of the L7 rule. One of: 'application', 'applicationCategory', 'host', 'port', 'ipRange'",
    )
    value: Optional[str] = Field(
        None,
        description="The 'value' of what you want to block. Format of 'value' varies depending on type of the rule. The application categories and application ids can be retrieved from the the 'MX L7 application categories' endpoint. The countries follow the two-letter ISO 3166-1 alpha-2 format.",
    )


class NetworksNetworkIdL7FirewallRulesPutRequest(BaseModel):
    rules: Optional[List[Rule4]] = Field(
        None, description='An ordered array of the MX L7 firewall rules'
    )


class NetworksNetworkIdL7FirewallRulesPutResponse(BaseModel):
    pass


class NetworksNetworkIdL7FirewallRulesApplicationCategoriesGetResponse(BaseModel):
    pass


class NetworksNetworkIdLatencyStatsGetResponse(BaseModel):
    pass


class NetworksNetworkIdMerakiAuthUsersGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdMerakiAuthUsersMerakiAuthUserIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdOneToManyNatRulesGetResponse(BaseModel):
    pass


class Protocol3(Enum):
    tcp = 'tcp'
    udp = 'udp'


class PortRule(BaseModel):
    allowedIps: Optional[List[str]] = Field(
        None,
        description="Remote IP addresses or ranges that are permitted to access the internal resource via this port forwarding rule, or 'any'",
    )
    localIp: Optional[str] = Field(
        None, description='Local IP address to which traffic will be forwarded'
    )
    localPort: Optional[str] = Field(
        None,
        description='Destination port of the forwarded traffic that will be sent from the MX to the specified host on the LAN. If you simply wish to forward the traffic without translating the port, this should be the same as the Public port',
    )
    name: Optional[str] = Field(None, description='A description of the rule')
    protocol: Optional[Protocol3] = Field(None, description="'tcp' or 'udp'")
    publicPort: Optional[str] = Field(
        None, description='Destination port of the traffic that is arriving on the WAN'
    )


class Uplink2(Enum):
    internet1 = 'internet1'
    internet2 = 'internet2'


class Rule5(BaseModel):
    portRules: List[PortRule] = Field(
        ..., description='An array of associated forwarding rules'
    )
    publicIp: str = Field(
        ...,
        description='The IP address that will be used to access the internal resource from the WAN',
    )
    uplink: Uplink2 = Field(
        ...,
        description="The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')",
    )


class NetworksNetworkIdOneToManyNatRulesPutRequest(BaseModel):
    rules: List[Rule5] = Field(..., description='An array of 1:Many nat rules')


class NetworksNetworkIdOneToManyNatRulesPutResponse(BaseModel):
    pass


class NetworksNetworkIdOneToOneNatRulesGetResponse(BaseModel):
    pass


class Protocol4(Enum):
    any = 'any'
    icmp_ping = 'icmp-ping'
    tcp = 'tcp'
    udp = 'udp'


class AllowedInboundItem(BaseModel):
    allowedIps: Optional[List[str]] = Field(
        None,
        description="An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges, or 'any'",
    )
    destinationPorts: Optional[List[str]] = Field(
        None,
        description='An array of ports or port ranges that will be forwarded to the host on the LAN',
    )
    protocol: Optional[Protocol4] = Field(
        None, description="Either of the following: 'tcp', 'udp', 'icmp-ping' or 'any'"
    )


class Rule6(BaseModel):
    allowedInbound: Optional[List[AllowedInboundItem]] = Field(
        None,
        description='The ports this mapping will provide access on, and the remote IPs that will be allowed access to the resource',
    )
    lanIp: str = Field(
        ...,
        description='The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN',
    )
    name: Optional[str] = Field(None, description='A descriptive name for the rule')
    publicIp: Optional[str] = Field(
        None,
        description='The IP address that will be used to access the internal resource from the WAN',
    )
    uplink: Optional[Uplink2] = Field(
        None,
        description="The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2')",
    )


class NetworksNetworkIdOneToOneNatRulesPutRequest(BaseModel):
    rules: List[Rule6] = Field(..., description='An array of 1:1 nat rules')


class NetworksNetworkIdOneToOneNatRulesPutResponse(BaseModel):
    pass


class NetworksNetworkIdPiiPiiKeysGetResponse(BaseModel):
    pass


class NetworksNetworkIdPiiRequestsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class Type1(Enum):
    delete = 'delete'
    restrict_processing = 'restrict processing'


class NetworksNetworkIdPiiRequestsPostRequest(BaseModel):
    datasets: Optional[List[str]] = Field(
        None,
        description='The datasets related to the provided key that should be deleted. Only applies to "delete" requests. The value "all" will be expanded to all datasets applicable to this type. The datasets by applicable to each type are: mac (usage, events, traffic), email (users, loginAttempts), username (users, loginAttempts), bluetoothMac (client, connectivity), smDeviceId (device), smUserId (user)',
    )
    email: Optional[str] = Field(
        None,
        description='The email of a network user account. Only applies to "delete" requests.',
    )
    mac: Optional[str] = Field(
        None,
        description='The MAC of a network client device. Applies to both "restrict processing" and "delete" requests.',
    )
    smDeviceId: Optional[str] = Field(
        None,
        description='The sm_device_id of a Systems Manager device. The only way to "restrict processing" or "delete" a Systems Manager device. Must include "device" in the dataset for a "delete" request to destroy the device.',
    )
    smUserId: Optional[str] = Field(
        None,
        description='The sm_user_id of a Systems Manager user. The only way to "restrict processing" or "delete" a Systems Manager user. Must include "user" in the dataset for a "delete" request to destroy the user.',
    )
    type: Optional[Type1] = Field(
        None, description='One of "delete" or "restrict processing"'
    )
    username: Optional[str] = Field(
        None,
        description='The username of a network log in. Only applies to "delete" requests.',
    )


class NetworksNetworkIdPiiRequestsPostResponse(BaseModel):
    pass


class NetworksNetworkIdPiiRequestsRequestIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdPiiSmDevicesForKeyGetResponse(BaseModel):
    pass


class NetworksNetworkIdPiiSmOwnersForKeyGetResponse(BaseModel):
    pass


class NetworksNetworkIdPortForwardingRulesGetResponse(BaseModel):
    pass


class Protocol5(Enum):
    tcp = 'tcp'
    udp = 'udp'


class Uplink4(Enum):
    both = 'both'
    internet1 = 'internet1'
    internet2 = 'internet2'


class Rule7(BaseModel):
    allowedIps: List[str] = Field(
        ...,
        description='An array of ranges of WAN IP addresses that are allowed to make inbound connections on the specified ports or port ranges (or any)',
    )
    lanIp: str = Field(
        ...,
        description='The IP address of the server or device that hosts the internal resource that you wish to make available on the WAN',
    )
    localPort: str = Field(
        ...,
        description='A port or port ranges that will receive the forwarded traffic from the WAN',
    )
    name: Optional[str] = Field(None, description='A descriptive name for the rule')
    protocol: Protocol5 = Field(..., description='TCP or UDP')
    publicPort: str = Field(
        ...,
        description='A port or port ranges that will be forwarded to the host on the LAN',
    )
    uplink: Optional[Uplink4] = Field(
        None,
        description="The physical WAN interface on which the traffic will arrive ('internet1' or, if available, 'internet2' or 'both')",
    )


class NetworksNetworkIdPortForwardingRulesPutRequest(BaseModel):
    rules: List[Rule7] = Field(..., description='An array of port forwarding params')


class NetworksNetworkIdPortForwardingRulesPutResponse(BaseModel):
    pass


class NetworksNetworkIdSecurityIntrusionSettingsGetResponse(BaseModel):
    pass


class IdsRulesets(Enum):
    balanced = 'balanced'
    connectivity = 'connectivity'
    security = 'security'


class Mode(Enum):
    detection = 'detection'
    disabled = 'disabled'
    prevention = 'prevention'


class ProtectedNetworks(BaseModel):
    excludedCidr: Optional[List[str]] = Field(
        None,
        description="list of IP addresses or subnets being excluded from protection (required if 'useDefault' is false)",
    )
    includedCidr: Optional[List[str]] = Field(
        None,
        description="list of IP addresses or subnets being protected (required if 'useDefault' is false)",
    )
    useDefault: Optional[bool] = Field(
        None,
        description='true/false whether to use special IPv4 addresses: https://tools.ietf.org/html/rfc5735 (required). Default value is true if none currently saved',
    )


class NetworksNetworkIdSecurityIntrusionSettingsPutRequest(BaseModel):
    idsRulesets: Optional[IdsRulesets] = Field(
        None,
        description="Set the detection ruleset 'connectivity'/'balanced'/'security' (optional - omitting will leave current config unchanged). Default value is 'balanced' if none currently saved",
    )
    mode: Optional[Mode] = Field(
        None,
        description="Set mode to 'disabled'/'detection'/'prevention' (optional - omitting will leave current config unchanged)",
    )
    protectedNetworks: Optional[ProtectedNetworks] = Field(
        None,
        description="Set the included/excluded networks from the intrusion engine (optional - omitting will leave current config unchanged). This is available only in 'passthrough' mode",
    )


class NetworksNetworkIdSecurityIntrusionSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdSecurityMalwareSettingsGetResponse(BaseModel):
    pass


class AllowedFile(BaseModel):
    comment: str = Field(..., description='Comment about the allowed entity')
    sha256: str = Field(..., description='The file sha256 hash to allow')


class AllowedUrl(BaseModel):
    comment: str = Field(..., description='Comment about the allowed entity')
    url: str = Field(..., description='The url to allow')


class Mode1(Enum):
    disabled = 'disabled'
    enabled = 'enabled'


class NetworksNetworkIdSecurityMalwareSettingsPutRequest(BaseModel):
    allowedFiles: Optional[List[AllowedFile]] = Field(
        None,
        description='The sha256 digests of files that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing',
    )
    allowedUrls: Optional[List[AllowedUrl]] = Field(
        None,
        description='The urls that should be permitted by the malware detection engine. If omitted, the current config will remain unchanged. This is available only if your network supports AMP allow listing',
    )
    mode: Mode1 = Field(
        ...,
        description="Set mode to 'enabled' to enable malware prevention, otherwise 'disabled'",
    )


class NetworksNetworkIdSecurityMalwareSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdSecurityEventsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSiteToSiteVpnGetResponse(BaseModel):
    pass


class Hub(BaseModel):
    hubId: str = Field(..., description='The network ID of the hub.')
    useDefaultRoute: Optional[bool] = Field(
        None,
        description="Only valid in 'spoke' mode. Indicates whether default route traffic should be sent to this hub.",
    )


class Mode2(Enum):
    hub = 'hub'
    none = 'none'
    spoke = 'spoke'


class Subnet(BaseModel):
    localSubnet: str = Field(
        ..., description='The CIDR notation subnet used within the VPN'
    )
    useVpn: Optional[bool] = Field(
        None, description='Indicates the presence of the subnet in the VPN'
    )


class NetworksNetworkIdSiteToSiteVpnPutRequest(BaseModel):
    hubs: Optional[List[Hub]] = Field(
        None,
        description='The list of VPN hubs, in order of preference. In spoke mode, at least 1 hub is required.',
    )
    mode: Mode2 = Field(
        ...,
        description="The site-to-site VPN mode. Can be one of 'none', 'spoke' or 'hub'",
    )
    subnets: Optional[List[Subnet]] = Field(
        None, description='The list of subnets and their VPN presence.'
    )


class NetworksNetworkIdSiteToSiteVpnPutResponse(BaseModel):
    pass


class NetworksNetworkIdSmBypassActivationLockAttemptsPostRequest(BaseModel):
    ids: List[str] = Field(
        ..., description='The ids of the devices to attempt activation lock bypass.'
    )


class NetworksNetworkIdSmBypassActivationLockAttemptsPostResponse(BaseModel):
    pass


class NetworksNetworkIdSmBypassActivationLockAttemptsAttemptIdGetResponse(BaseModel):
    pass


class DeviceFields(BaseModel):
    name: Optional[str] = Field(None, description='New name for the device')
    notes: Optional[str] = Field(None, description='New notes for the device')


class NetworksNetworkIdSmDeviceFieldsPutRequest(BaseModel):
    deviceFields: DeviceFields = Field(
        ...,
        description='The new fields of the device. Each field of this object is optional.',
    )
    id: Optional[str] = Field(None, description='The id of the device to be modified.')
    serial: Optional[str] = Field(
        None, description='The serial of the device to be modified.'
    )
    wifiMac: Optional[str] = Field(
        None, description='The wifiMac of the device to be modified.'
    )


class NetworksNetworkIdSmDeviceFieldsPutResponse(BaseModel):
    pass


class NetworksNetworkIdSmDeviceWipePutRequest(BaseModel):
    id: Optional[str] = Field(None, description='The id of the device to be wiped.')
    pin: Optional[int] = Field(
        None,
        description='The pin number (a six digit value) for wiping a macOS device. Required only for macOS devices.',
    )
    serial: Optional[str] = Field(
        None, description='The serial of the device to be wiped.'
    )
    wifiMac: Optional[str] = Field(
        None, description='The wifiMac of the device to be wiped.'
    )


class NetworksNetworkIdSmDeviceWipePutResponse(BaseModel):
    pass


class NetworksNetworkIdSmDevicesGetResponse(BaseModel):
    pass


class NetworksNetworkIdSmDevicesCheckinPutRequest(BaseModel):
    ids: Optional[str] = Field(
        None, description='The ids of the devices to be checked-in.'
    )
    scope: Optional[str] = Field(
        None,
        description='The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be checked-in.',
    )
    serials: Optional[str] = Field(
        None, description='The serials of the devices to be checked-in.'
    )
    wifiMacs: Optional[str] = Field(
        None, description='The wifiMacs of the devices to be checked-in.'
    )


class NetworksNetworkIdSmDevicesCheckinPutResponse(BaseModel):
    pass


class NetworksNetworkIdSmDevicesTagsPutRequest(BaseModel):
    ids: Optional[str] = Field(
        None, description='The ids of the devices to be modified.'
    )
    scope: Optional[str] = Field(
        None,
        description='The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be modified.',
    )
    serials: Optional[str] = Field(
        None, description='The serials of the devices to be modified.'
    )
    tags: str = Field(..., description='The tags to be added, deleted, or updated.')
    updateAction: str = Field(
        ...,
        description='One of add, delete, or update. Only devices that have been modified will be returned.',
    )
    wifiMacs: Optional[str] = Field(
        None, description='The wifiMacs of the devices to be modified.'
    )


class NetworksNetworkIdSmDevicesTagsPutResponse(BaseModel):
    pass


class NetworksNetworkIdSmDevicesDeviceIdUnenrollPostResponse(BaseModel):
    pass


class NetworksNetworkIdSmProfilesGetResponse(BaseModel):
    pass


class NetworksNetworkIdSmTargetGroupsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmTargetGroupsPostRequest(BaseModel):
    name: Optional[str] = Field(None, description='The name of this target group')
    scope: Optional[str] = Field(
        None,
        description='The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.',
    )


class NetworksNetworkIdSmTargetGroupsPostResponse(BaseModel):
    pass


class NetworksNetworkIdSmTargetGroupsTargetGroupIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdSmTargetGroupsTargetGroupIdPutRequest(BaseModel):
    name: Optional[str] = Field(None, description='The name of this target group')
    scope: Optional[str] = Field(
        None,
        description='The scope and tag options of the target group. Comma separated values beginning with one of withAny, withAll, withoutAny, withoutAll, all, none, followed by tags. Default to none if empty.',
    )


class NetworksNetworkIdSmTargetGroupsTargetGroupIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdSmUserUserIdDeviceProfilesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmUserUserIdSoftwaresGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmUsersGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdCellularUsageHistoryGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdCertsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdDeviceProfilesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdNetworkAdaptersGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdRestrictionsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdSecurityCentersGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdSoftwaresGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmDeviceIdWlanListsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSnmpSettingsGetResponse(BaseModel):
    pass


class SsidNumber(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2
    integer_3 = 3
    integer_4 = 4
    integer_5 = 5
    integer_6 = 6
    integer_7 = 7
    integer_8 = 8
    integer_9 = 9
    integer_10 = 10
    integer_11 = 11
    integer_12 = 12
    integer_13 = 13
    integer_14 = 14


class NetworksNetworkIdSplashLoginAttemptsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSplitPostResponse(BaseModel):
    pass


class NetworksNetworkIdSsidsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSsidsNumberGetResponse(BaseModel):
    pass


class ApTagsAndVlanId(BaseModel):
    tags: Optional[str] = Field(None, description='Comma-separated list of AP tags')
    vlanId: Optional[int] = Field(
        None, description='Numerical identifier that is assigned to the VLAN'
    )


class AuthMode(Enum):
    field_8021x_google = '8021x-google'
    field_8021x_localradius = '8021x-localradius'
    field_8021x_meraki = '8021x-meraki'
    field_8021x_nac = '8021x-nac'
    field_8021x_radius = '8021x-radius'
    ipsk_with_radius = 'ipsk-with-radius'
    ipsk_without_radius = 'ipsk-without-radius'
    open = 'open'
    open_enhanced = 'open-enhanced'
    open_with_nac = 'open-with-nac'
    open_with_radius = 'open-with-radius'
    psk = 'psk'


class EncryptionMode(Enum):
    wep = 'wep'
    wpa = 'wpa'


class EnterpriseAdminAccess(Enum):
    access_disabled = 'access disabled'
    access_enabled = 'access enabled'


class RadiusAccountingServer(BaseModel):
    host: str = Field(
        ...,
        description='IP address to which the APs will send RADIUS accounting messages',
    )
    port: Optional[int] = Field(
        None,
        description='Port on the RADIUS server that is listening for accounting messages',
    )
    secret: Optional[str] = Field(
        None,
        description='Shared key used to authenticate messages between the APs and RADIUS server',
    )


class RadiusFailoverPolicy(Enum):
    Allow_access = 'Allow access'
    Deny_access = 'Deny access'


class RadiusLoadBalancingPolicy(Enum):
    Round_robin = 'Round robin'
    Strict_priority_order = 'Strict priority order'


class RadiusServer(BaseModel):
    host: str = Field(..., description='IP address of your RADIUS server')
    port: Optional[int] = Field(
        None, description='UDP port the RADIUS server listens on for Access-requests'
    )
    secret: Optional[str] = Field(None, description='RADIUS client shared secret')


class SplashPage(Enum):
    Billing = 'Billing'
    Cisco_ISE = 'Cisco ISE'
    Click_through_splash_page = 'Click-through splash page'
    Facebook_Wi_Fi = 'Facebook Wi-Fi'
    Google_Apps_domain = 'Google Apps domain'
    Google_OAuth = 'Google OAuth'
    None_ = 'None'
    Password_protected_with_Active_Directory = (
        'Password-protected with Active Directory'
    )
    Password_protected_with_LDAP = 'Password-protected with LDAP'
    Password_protected_with_Meraki_RADIUS = 'Password-protected with Meraki RADIUS'
    Password_protected_with_custom_RADIUS = 'Password-protected with custom RADIUS'
    SMS_authentication = 'SMS authentication'
    Sponsored_guest = 'Sponsored guest'
    Systems_Manager_Sentry = 'Systems Manager Sentry'


class WpaEncryptionMode(Enum):
    WPA1_and_WPA2 = 'WPA1 and WPA2'
    WPA1_only = 'WPA1 only'
    WPA2_only = 'WPA2 only'
    WPA3_Transition_Mode = 'WPA3 Transition Mode'
    WPA3_only = 'WPA3 only'


class NetworksNetworkIdSsidsNumberPutRequest(BaseModel):
    apTagsAndVlanIds: Optional[List[ApTagsAndVlanId]] = Field(
        None,
        description="The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'",
    )
    authMode: Optional[AuthMode] = Field(
        None,
        description="The association control method for the SSID ('open', 'open-enhanced', 'psk', 'open-with-radius', 'open-with-nac', '8021x-meraki', '8021x-nac', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')",
    )
    availabilityTags: Optional[List[str]] = Field(
        None,
        description='Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.',
    )
    availableOnAllAps: Optional[bool] = Field(
        None,
        description='Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.',
    )
    bandSelection: Optional[str] = Field(
        None,
        description="The client-serving radio frequencies of this SSID in the default indoor RF profile. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')",
    )
    concentratorNetworkId: Optional[str] = Field(
        None,
        description="The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.",
    )
    defaultVlanId: Optional[int] = Field(
        None,
        description="The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'",
    )
    disassociateClientsOnVpnFailover: Optional[bool] = Field(
        None,
        description="Disassociate clients when 'VPN' concentrator failover occurs in order to trigger clients to re-associate and generate new DHCP requests. This param is only valid if ipAssignmentMode is 'VPN'.",
    )
    enabled: Optional[bool] = Field(
        None, description='Whether or not the SSID is enabled'
    )
    encryptionMode: Optional[EncryptionMode] = Field(
        None,
        description="The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'",
    )
    enterpriseAdminAccess: Optional[EnterpriseAdminAccess] = Field(
        None,
        description="Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')",
    )
    ipAssignmentMode: Optional[str] = Field(
        None,
        description="The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Ethernet over GRE', 'Layer 3 roaming with a concentrator' or 'VPN')",
    )
    lanIsolationEnabled: Optional[bool] = Field(
        None,
        description="Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.",
    )
    minBitrate: Optional[float] = Field(
        None,
        description="The minimum bitrate in Mbps of this SSID in the default indoor RF profile. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')",
    )
    name: Optional[str] = Field(None, description='The name of the SSID')
    perClientBandwidthLimitDown: Optional[int] = Field(
        None,
        description='The download bandwidth limit in Kbps. (0 represents no limit.)',
    )
    perClientBandwidthLimitUp: Optional[int] = Field(
        None, description='The upload bandwidth limit in Kbps. (0 represents no limit.)'
    )
    psk: Optional[str] = Field(
        None,
        description="The passkey for the SSID. This param is only valid if the authMode is 'psk'",
    )
    radiusAccountingEnabled: Optional[bool] = Field(
        None,
        description="Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'",
    )
    radiusAccountingServers: Optional[List[RadiusAccountingServer]] = Field(
        None,
        description="The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'",
    )
    radiusAttributeForGroupPolicies: Optional[str] = Field(
        None,
        description="Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message",
    )
    radiusCoaEnabled: Optional[bool] = Field(
        None,
        description='If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.',
    )
    radiusFailoverPolicy: Optional[RadiusFailoverPolicy] = Field(
        None,
        description="This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')",
    )
    radiusLoadBalancingPolicy: Optional[RadiusLoadBalancingPolicy] = Field(
        None,
        description="This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')",
    )
    radiusOverride: Optional[bool] = Field(
        None,
        description="If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.",
    )
    radiusServers: Optional[List[RadiusServer]] = Field(
        None,
        description="The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'",
    )
    secondaryConcentratorNetworkId: Optional[str] = Field(
        None,
        description="The secondary concentrator to use when the ipAssignmentMode is 'VPN'. If configured, the APs will switch to using this concentrator if the primary concentrator is unreachable. This param is optional. ('disabled' represents no secondary concentrator.)",
    )
    splashPage: Optional[SplashPage] = Field(
        None,
        description="The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.",
    )
    useVlanTagging: Optional[bool] = Field(
        None,
        description="Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'",
    )
    visible: Optional[bool] = Field(
        None,
        description='Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true',
    )
    vlanId: Optional[int] = Field(
        None,
        description="The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'",
    )
    walledGardenEnabled: Optional[bool] = Field(
        None,
        description='Allow access to a configurable list of IP ranges, which users may access prior to sign-on.',
    )
    walledGardenRanges: Optional[str] = Field(
        None,
        description="Specify your walled garden by entering space-separated addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. 192.168.1.1/24 192.168.37.10/32 www.yahoo.com *.google.com). Meraki's splash page is automatically included in your walled garden.",
    )
    wpaEncryptionMode: Optional[WpaEncryptionMode] = Field(
        None,
        description="The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')",
    )


class NetworksNetworkIdSsidsNumberPutResponse(BaseModel):
    pass


class NetworksNetworkIdSsidsNumberL3FirewallRulesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Policy4(Enum):
    allow = 'allow'
    deny = 'deny'


class Protocol6(Enum):
    any = 'any'
    icmp = 'icmp'
    icmp6 = 'icmp6'
    tcp = 'tcp'
    udp = 'udp'


class Rule8(BaseModel):
    comment: Optional[str] = Field(
        None, description='Description of the rule (optional)'
    )
    destCidr: str = Field(
        ...,
        description="Comma-separated list of destination IP address(es) (in IP or CIDR notation), fully-qualified domain names (FQDN) or 'any'",
    )
    destPort: Optional[str] = Field(
        None,
        description="Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'",
    )
    policy: Policy4 = Field(
        ..., description="'allow' or 'deny' traffic specified by this rule"
    )
    protocol: Protocol6 = Field(
        ...,
        description="The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')",
    )


class NetworksNetworkIdSsidsNumberL3FirewallRulesPutRequest(BaseModel):
    allowLanAccess: Optional[bool] = Field(
        None,
        description='Allow wireless client access to local LAN (boolean value - true allows access and false denies access) (optional)',
    )
    rules: Optional[List[Rule8]] = Field(
        None,
        description='An ordered array of the firewall rules for this SSID (not including the local LAN access rule or the default rule)',
    )


class NetworksNetworkIdSsidsNumberL3FirewallRulesPutResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSsidsNumberSplashSettingsGetResponse(BaseModel):
    pass


class NetworksNetworkIdSsidsNumberSplashSettingsPutRequest(BaseModel):
    splashUrl: Optional[str] = Field(
        None,
        description="[optional] The custom splash URL of the click-through splash page. Note that the URL can be configured without necessarily being used. In order to enable the custom URL, see 'useSplashUrl'",
    )
    useSplashUrl: Optional[bool] = Field(
        None,
        description="[optional] Boolean indicating whether the user will be redirected to the custom splash url. A custom splash URL must be set if this is true. Note that depending on your SSID's access control settings, it may not be possible to use the custom splash URL.",
    )


class NetworksNetworkIdSsidsNumberSplashSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdStaticRoutesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdStaticRoutesPostRequest(BaseModel):
    gatewayIp: str = Field(
        ..., description='The gateway IP (next hop) of the static route'
    )
    name: str = Field(..., description='The name of the new static route')
    subnet: str = Field(..., description='The subnet of the static route')


class NetworksNetworkIdStaticRoutesPostResponse(BaseModel):
    pass


class NetworksNetworkIdStaticRoutesStaticRouteIdGetResponse(BaseModel):
    pass


class ReservedIpRange1(BaseModel):
    comment: str = Field(..., description='A text comment for the reserved range')
    end: str = Field(..., description='The last IP in the reserved range')
    start: str = Field(..., description='The first IP in the reserved range')


class NetworksNetworkIdStaticRoutesStaticRouteIdPutRequest(BaseModel):
    enabled: Optional[bool] = Field(
        None, description='The enabled state of the static route'
    )
    fixedIpAssignments: Optional[Dict[str, Any]] = Field(
        None,
        description='The DHCP fixed IP assignments on the static route. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.',
    )
    gatewayIp: Optional[str] = Field(
        None, description='The gateway IP (next hop) of the static route'
    )
    name: Optional[str] = Field(None, description='The name of the static route')
    reservedIpRanges: Optional[List[ReservedIpRange1]] = Field(
        None, description='The DHCP reserved IP ranges on the static route'
    )
    subnet: Optional[str] = Field(None, description='The subnet of the static route')


class NetworksNetworkIdStaticRoutesStaticRouteIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwapWarmSparePostResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchLinkAggregationsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class SwitchPort(BaseModel):
    portId: str = Field(
        ...,
        description='Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").',
    )
    serial: str = Field(..., description='Serial number of the switch.')


class SwitchProfilePort(BaseModel):
    portId: str = Field(
        ...,
        description='Port identifier of switch port. For modules, the identifier is "SlotNumber_ModuleType_PortNumber" (Ex: "1_8X10G_1"), otherwise it is just the port number (Ex: "8").',
    )
    profile: str = Field(..., description='Profile identifier.')


class NetworksNetworkIdSwitchLinkAggregationsPostRequest(BaseModel):
    switchPorts: Optional[List[SwitchPort]] = Field(
        None,
        description='Array of switch or stack ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.',
    )
    switchProfilePorts: Optional[List[SwitchProfilePort]] = Field(
        None,
        description='Array of switch profile ports for creating aggregation group. Minimum 2 and maximum 8 ports are supported.',
    )


class NetworksNetworkIdSwitchLinkAggregationsPostResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchLinkAggregationsLinkAggregationIdPutRequest(BaseModel):
    switchPorts: Optional[List[SwitchPort]] = Field(
        None,
        description='Array of switch or stack ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.',
    )
    switchProfilePorts: Optional[List[SwitchProfilePort]] = Field(
        None,
        description='Array of switch profile ports for updating aggregation group. Minimum 2 and maximum 8 ports are supported.',
    )


class NetworksNetworkIdSwitchLinkAggregationsLinkAggregationIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchPortSchedulesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class Friday(BaseModel):
    active: Optional[bool] = Field(
        None,
        description="Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.",
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description="The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.",
    )
    to: Optional[str] = Field(
        None,
        description="The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.",
    )


class Monday(BaseModel):
    active: Optional[bool] = Field(
        None,
        description="Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.",
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description="The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.",
    )
    to: Optional[str] = Field(
        None,
        description="The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.",
    )


class Saturday(BaseModel):
    active: Optional[bool] = Field(
        None,
        description="Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.",
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description="The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.",
    )
    to: Optional[str] = Field(
        None,
        description="The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.",
    )


class Sunday(BaseModel):
    active: Optional[bool] = Field(
        None,
        description="Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.",
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description="The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.",
    )
    to: Optional[str] = Field(
        None,
        description="The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.",
    )


class Thursday(BaseModel):
    active: Optional[bool] = Field(
        None,
        description="Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.",
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description="The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.",
    )
    to: Optional[str] = Field(
        None,
        description="The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.",
    )


class Tuesday(BaseModel):
    active: Optional[bool] = Field(
        None,
        description="Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.",
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description="The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.",
    )
    to: Optional[str] = Field(
        None,
        description="The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.",
    )


class Wednesday(BaseModel):
    active: Optional[bool] = Field(
        None,
        description="Whether the schedule is active (true) or inactive (false) during the time specified between 'from' and 'to'. Defaults to true.",
    )
    from_: Optional[str] = Field(
        None,
        alias='from',
        description="The time, from '00:00' to '24:00'. Must be less than the time specified in 'to'. Defaults to '00:00'. Only 30 minute increments are allowed.",
    )
    to: Optional[str] = Field(
        None,
        description="The time, from '00:00' to '24:00'. Must be greater than the time specified in 'from'. Defaults to '24:00'. Only 30 minute increments are allowed.",
    )


class PortSchedule(BaseModel):
    friday: Optional[Friday] = Field(
        None, description='The schedule object for Friday.'
    )
    monday: Optional[Monday] = Field(
        None, description='The schedule object for Monday.'
    )
    saturday: Optional[Saturday] = Field(
        None, description='The schedule object for Saturday.'
    )
    sunday: Optional[Sunday] = Field(
        None, description='The schedule object for Sunday.'
    )
    thursday: Optional[Thursday] = Field(
        None, description='The schedule object for Thursday.'
    )
    tuesday: Optional[Tuesday] = Field(
        None, description='The schedule object for Tuesday.'
    )
    wednesday: Optional[Wednesday] = Field(
        None, description='The schedule object for Wednesday.'
    )


class NetworksNetworkIdSwitchPortSchedulesPostRequest(BaseModel):
    name: str = Field(..., description='The name for your port schedule. Required')
    portSchedule: Optional[PortSchedule] = Field(
        None,
        description="    The schedule for switch port scheduling. Schedules are applied to days of the week.\n    When it's empty, default schedule with all days of a week are configured.\n    Any unspecified day in the schedule is added as a default schedule configuration of the day.\n",
    )


class NetworksNetworkIdSwitchPortSchedulesPostResponse(BaseModel):
    pass


class PortSchedule1(BaseModel):
    friday: Optional[Friday] = Field(
        None, description='The schedule object for Friday.'
    )
    monday: Optional[Monday] = Field(
        None, description='The schedule object for Monday.'
    )
    saturday: Optional[Saturday] = Field(
        None, description='The schedule object for Saturday.'
    )
    sunday: Optional[Sunday] = Field(
        None, description='The schedule object for Sunday.'
    )
    thursday: Optional[Thursday] = Field(
        None, description='The schedule object for Thursday.'
    )
    tuesday: Optional[Tuesday] = Field(
        None, description='The schedule object for Tuesday.'
    )
    wednesday: Optional[Wednesday] = Field(
        None, description='The schedule object for Wednesday.'
    )


class NetworksNetworkIdSwitchPortSchedulesPortScheduleIdPutRequest(BaseModel):
    name: Optional[str] = Field(None, description='The name for your port schedule.')
    portSchedule: Optional[PortSchedule1] = Field(
        None,
        description="    The schedule for switch port scheduling. Schedules are applied to days of the week.\n    When it's empty, default schedule with all days of a week are configured.\n    Any unspecified day in the schedule is added as a default schedule configuration of the day.\n",
    )


class NetworksNetworkIdSwitchPortSchedulesPortScheduleIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsGetResponse(BaseModel):
    pass


class PowerType(Enum):
    combined = 'combined'
    redundant = 'redundant'
    useNetworkSetting = 'useNetworkSetting'


class PowerException(BaseModel):
    powerType: PowerType = Field(
        ..., description='Per switch exception (combined, redundant, useNetworkSetting)'
    )
    serial: str = Field(..., description='Serial number of the switch')


class NetworksNetworkIdSwitchSettingsPutRequest(BaseModel):
    powerExceptions: Optional[List[PowerException]] = Field(
        None, description='Exceptions on a per switch basis to "useCombinedPower"'
    )
    useCombinedPower: Optional[bool] = Field(
        None,
        description='The use Combined Power as the default behavior of secondary power supplies on supported devices.',
    )
    vlan: Optional[int] = Field(None, description='Management VLAN')


class NetworksNetworkIdSwitchSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsMtuGetResponse(BaseModel):
    pass


class Override(BaseModel):
    mtuSize: int = Field(
        ..., description='MTU size for the switches or switch profiles.'
    )
    switchProfiles: Optional[List[str]] = Field(
        None,
        description='List of switch profile IDs. Applicable only for template network.',
    )
    switches: Optional[List[str]] = Field(
        None, description='List of switch serials. Applicable only for switch network.'
    )


class NetworksNetworkIdSwitchSettingsMtuPutRequest(BaseModel):
    defaultMtuSize: Optional[int] = Field(
        None, description='MTU size for the entire network. Default value is 9578.'
    )
    overrides: Optional[List[Override]] = Field(
        None,
        description='Override MTU size for individual switches or switch profiles. An empty array will clear overrides.',
    )


class NetworksNetworkIdSwitchSettingsMtuPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsMulticastGetResponse(BaseModel):
    pass


class DefaultSettings(BaseModel):
    floodUnknownMulticastTrafficEnabled: Optional[bool] = Field(
        None, description='Flood unknown multicast traffic setting for entire network'
    )
    igmpSnoopingEnabled: Optional[bool] = Field(
        None, description='IGMP snooping setting for entire network'
    )


class Override1(BaseModel):
    floodUnknownMulticastTrafficEnabled: bool = Field(
        ...,
        description='Flood unknown multicast traffic setting for switches, switch stacks or switch profiles',
    )
    igmpSnoopingEnabled: bool = Field(
        ...,
        description='IGMP snooping setting for switches, switch stacks or switch profiles',
    )
    stacks: Optional[List[str]] = Field(
        None, description='List of switch stack ids for non-template network'
    )
    switchProfiles: Optional[List[str]] = Field(
        None, description='List of switch profiles ids for template network'
    )
    switches: Optional[List[str]] = Field(
        None, description='List of switch serials for non-template network'
    )


class NetworksNetworkIdSwitchSettingsMulticastPutRequest(BaseModel):
    defaultSettings: Optional[DefaultSettings] = Field(
        None,
        description='Default multicast setting for entire network. IGMP snooping and Flood unknown multicast traffic settings are enabled by default.',
    )
    overrides: Optional[List[Override1]] = Field(
        None,
        description='Array of paired switches/stacks/profiles and corresponding multicast settings. An empty array will clear the multicast settings.',
    )


class NetworksNetworkIdSwitchSettingsMulticastPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsQosRulesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Protocol7(Enum):
    ANY = 'ANY'
    TCP = 'TCP'
    UDP = 'UDP'


class NetworksNetworkIdSwitchSettingsQosRulesPostRequest(BaseModel):
    dscp: Optional[int] = Field(
        None,
        description='DSCP tag. Set this to -1 to trust incoming DSCP. Default value is 0',
    )
    dstPort: Optional[int] = Field(
        None,
        description='The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.',
    )
    dstPortRange: Optional[str] = Field(
        None,
        description='The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80',
    )
    protocol: Optional[Protocol7] = Field(
        None,
        description='The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY"',
    )
    srcPort: Optional[int] = Field(
        None,
        description='The source port of the incoming packet. Applicable only if protocol is TCP or UDP.',
    )
    srcPortRange: Optional[str] = Field(
        None,
        description='The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80',
    )
    vlan: int = Field(
        ...,
        description='The VLAN of the incoming packet. A null value will match any VLAN.',
    )


class NetworksNetworkIdSwitchSettingsQosRulesPostResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsQosRulesOrderGetResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsQosRulesOrderPutRequest(BaseModel):
    ruleIds: List[str] = Field(
        ...,
        description='A list of quality of service rule IDs arranged in order in which they should be processed by the switch.',
    )


class NetworksNetworkIdSwitchSettingsQosRulesOrderPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsQosRulesQosRuleIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsQosRulesQosRuleIdPutRequest(BaseModel):
    dscp: Optional[int] = Field(
        None,
        description='DSCP tag that should be assigned to incoming packet. Set this to -1 to trust incoming DSCP. Default value is 0.',
    )
    dstPort: Optional[int] = Field(
        None,
        description='The destination port of the incoming packet. Applicable only if protocol is TCP or UDP.',
    )
    dstPortRange: Optional[str] = Field(
        None,
        description='The destination port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80',
    )
    protocol: Optional[Protocol7] = Field(
        None,
        description='The protocol of the incoming packet. Can be one of "ANY", "TCP" or "UDP". Default value is "ANY".',
    )
    srcPort: Optional[int] = Field(
        None,
        description='The source port of the incoming packet. Applicable only if protocol is TCP or UDP.',
    )
    srcPortRange: Optional[str] = Field(
        None,
        description='The source port range of the incoming packet. Applicable only if protocol is set to TCP or UDP. Example: 70-80',
    )
    vlan: Optional[int] = Field(
        None,
        description='The VLAN of the incoming packet. A null value will match any VLAN.',
    )


class NetworksNetworkIdSwitchSettingsQosRulesQosRuleIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsStormControlGetResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchSettingsStormControlPutRequest(BaseModel):
    broadcastThreshold: Optional[int] = Field(
        None,
        description='Percentage (1 to 99) of total available port bandwidth for broadcast traffic type. Default value 100 percent rate is to clear the configuration.',
    )
    multicastThreshold: Optional[int] = Field(
        None,
        description='Percentage (1 to 99) of total available port bandwidth for multicast traffic type. Default value 100 percent rate is to clear the configuration.',
    )
    unknownUnicastThreshold: Optional[int] = Field(
        None,
        description='Percentage (1 to 99) of total available port bandwidth for unknown unicast (dlf-destination lookup failure) traffic type. Default value 100 percent rate is to clear the configuration.',
    )


class NetworksNetworkIdSwitchSettingsStormControlPutResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchStacksGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSwitchStacksPostRequest(BaseModel):
    name: str = Field(..., description='The name of the new stack')
    serials: List[str] = Field(
        ..., description='An array of switch serials to be added into the new stack'
    )


class NetworksNetworkIdSwitchStacksPostResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchStacksSwitchStackIdGetResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchStacksSwitchStackIdAddPostRequest(BaseModel):
    serial: str = Field(..., description='The serial of the switch to be added')


class NetworksNetworkIdSwitchStacksSwitchStackIdAddPostResponse(BaseModel):
    pass


class NetworksNetworkIdSwitchStacksSwitchStackIdRemovePostRequest(BaseModel):
    serial: str = Field(..., description='The serial of the switch to be removed')


class NetworksNetworkIdSwitchStacksSwitchStackIdRemovePostResponse(BaseModel):
    pass


class NetworksNetworkIdSyslogServersGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class Server(BaseModel):
    host: str = Field(..., description='The IP address of the syslog server')
    port: int = Field(..., description='The port of the syslog server')
    roles: List[str] = Field(
        ...,
        description="A list of roles for the syslog server. Options (case-insensitive): 'Wireless event log', 'Appliance event log', 'Switch event log', 'Air Marshal events', 'Flows', 'URLs', 'IDS alerts', 'Security events'",
    )


class NetworksNetworkIdSyslogServersPutRequest(BaseModel):
    servers: List[Server] = Field(
        ..., description='A list of the syslog servers for this network'
    )


class NetworksNetworkIdSyslogServersPutResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class DeviceType(Enum):
    appliance = 'appliance'
    combined = 'combined'
    switch = 'switch'
    wireless = 'wireless'


class NetworksNetworkIdTrafficGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdUplinkSettingsGetResponse(BaseModel):
    pass


class Cellular(BaseModel):
    limitDown: Optional[int] = Field(
        None,
        description='The maximum download limit (integer, in Kbps). null indicates no limit',
    )
    limitUp: Optional[int] = Field(
        None,
        description='The maximum upload limit (integer, in Kbps). null indicates no limit',
    )


class Wan1(BaseModel):
    limitDown: Optional[int] = Field(
        None,
        description='The maximum download limit (integer, in Kbps). null indicates no limit',
    )
    limitUp: Optional[int] = Field(
        None,
        description='The maximum upload limit (integer, in Kbps). null indicates no limit',
    )


class Wan2(BaseModel):
    limitDown: Optional[int] = Field(
        None,
        description='The maximum download limit (integer, in Kbps). null indicates no limit',
    )
    limitUp: Optional[int] = Field(
        None,
        description='The maximum upload limit (integer, in Kbps). null indicates no limit',
    )


class BandwidthLimits(BaseModel):
    cellular: Optional[Cellular] = Field(
        None, description="The bandwidth settings for the 'cellular' uplink"
    )
    wan1: Optional[Wan1] = Field(
        None, description="The bandwidth settings for the 'wan1' uplink"
    )
    wan2: Optional[Wan2] = Field(
        None, description="The bandwidth settings for the 'wan2' uplink"
    )


class NetworksNetworkIdUplinkSettingsPutRequest(BaseModel):
    bandwidthLimits: Optional[BandwidthLimits] = Field(
        None,
        description='A mapping of uplinks to their bandwidth settings (be sure to check which uplinks are supported for your network)',
    )


class NetworksNetworkIdUplinkSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdVlansGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdVlansPostRequest(BaseModel):
    applianceIp: str = Field(
        ..., description='The local IP of the appliance on the VLAN'
    )
    groupPolicyId: Optional[str] = Field(
        None, description='The id of the desired group policy to apply to the VLAN'
    )
    id: str = Field(
        ..., description='The VLAN ID of the new VLAN (must be between 1 and 4094)'
    )
    name: str = Field(..., description='The name of the new VLAN')
    subnet: str = Field(..., description='The subnet of the VLAN')


class NetworksNetworkIdVlansPostResponse(BaseModel):
    pass


class NetworksNetworkIdVlansVlanIdGetResponse(BaseModel):
    pass


class DhcpHandling(Enum):
    Do_not_respond_to_DHCP_requests = 'Do not respond to DHCP requests'
    Relay_DHCP_to_another_server = 'Relay DHCP to another server'
    Run_a_DHCP_server = 'Run a DHCP server'


class DhcpLeaseTime(Enum):
    field_1_day = '1 day'
    field_1_hour = '1 hour'
    field_1_week = '1 week'
    field_12_hours = '12 hours'
    field_30_minutes = '30 minutes'
    field_4_hours = '4 hours'


class Type2(Enum):
    hex = 'hex'
    integer = 'integer'
    ip = 'ip'
    text = 'text'


class DhcpOption(BaseModel):
    code: str = Field(
        ...,
        description='The code for the DHCP option. This should be an integer between 2 and 254.',
    )
    type: Type2 = Field(
        ...,
        description="The type for the DHCP option. One of: 'text', 'ip', 'hex' or 'integer'",
    )
    value: str = Field(..., description='The value for the DHCP option')


class NetworksNetworkIdVlansVlanIdPutRequest(BaseModel):
    applianceIp: Optional[str] = Field(
        None, description='The local IP of the appliance on the VLAN'
    )
    dhcpBootFilename: Optional[str] = Field(
        None, description='DHCP boot option for boot filename'
    )
    dhcpBootNextServer: Optional[str] = Field(
        None,
        description='DHCP boot option to direct boot clients to the server to load the boot file from',
    )
    dhcpBootOptionsEnabled: Optional[bool] = Field(
        None, description='Use DHCP boot options specified in other properties'
    )
    dhcpHandling: Optional[DhcpHandling] = Field(
        None,
        description="The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'",
    )
    dhcpLeaseTime: Optional[DhcpLeaseTime] = Field(
        None,
        description="The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'",
    )
    dhcpOptions: Optional[List[DhcpOption]] = Field(
        None,
        description='The list of DHCP options that will be included in DHCP responses. Each object in the list should have "code", "type", and "value" properties.',
    )
    dhcpRelayServerIps: Optional[List[str]] = Field(
        None,
        description='The IPs of the DHCP servers that DHCP requests should be relayed to',
    )
    dnsNameservers: Optional[str] = Field(
        None,
        description='The DNS nameservers used for DHCP responses, either "upstream_dns", "google_dns", "opendns", or a newline seperated string of IP addresses or domain names',
    )
    fixedIpAssignments: Optional[Dict[str, Any]] = Field(
        None,
        description='The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain "ip" and "name" string fields. See the sample request/response for more details.',
    )
    groupPolicyId: Optional[str] = Field(
        None, description='The id of the desired group policy to apply to the VLAN'
    )
    name: Optional[str] = Field(None, description='The name of the VLAN')
    reservedIpRanges: Optional[List[ReservedIpRange1]] = Field(
        None, description='The DHCP reserved IP ranges on the VLAN'
    )
    subnet: Optional[str] = Field(None, description='The subnet of the VLAN')
    vpnNatSubnet: Optional[str] = Field(
        None,
        description='The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN',
    )


class NetworksNetworkIdVlansVlanIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdVlansEnabledStateGetResponse(BaseModel):
    pass


class NetworksNetworkIdVlansEnabledStatePutRequest(BaseModel):
    enabled: bool = Field(
        ...,
        description='Boolean indicating whether to enable (true) or disable (false) VLANs for the network',
    )


class NetworksNetworkIdVlansEnabledStatePutResponse(BaseModel):
    pass


class NetworksNetworkIdWarmSpareSettingsGetResponse(BaseModel):
    pass


class NetworksNetworkIdWarmSpareSettingsPutRequest(BaseModel):
    enabled: bool = Field(..., description='Enable warm spare')
    spareSerial: Optional[str] = Field(
        None, description='Serial number of the warm spare appliance'
    )
    uplinkMode: Optional[str] = Field(
        None, description='Uplink mode, either virtual or public'
    )
    virtualIp1: Optional[str] = Field(None, description='The WAN 1 shared IP')
    virtualIp2: Optional[str] = Field(None, description='The WAN 2 shared IP')


class NetworksNetworkIdWarmSpareSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdWirelessRfProfilesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class BandOperationMode(Enum):
    field_2_4ghz = '2.4ghz'
    field_5ghz = '5ghz'
    dual = 'dual'


class ApBandSettings(BaseModel):
    bandOperationMode: Optional[BandOperationMode] = Field(
        None, description="Choice between 'dual', '2.4ghz' or '5ghz'. Defaults to dual."
    )
    bandSteeringEnabled: Optional[bool] = Field(
        None,
        description='Steers client to most open band. Can be either true or false. Defaults to true.',
    )


class BandSelectionType(Enum):
    ap = 'ap'
    ssid = 'ssid'


class FiveGhzSettings(BaseModel):
    channelWidth: Optional[str] = Field(
        None,
        description="Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'. Defaults to auto.",
    )
    maxPower: Optional[int] = Field(
        None,
        description='Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 30.',
    )
    minBitrate: Optional[int] = Field(
        None,
        description="Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'. Defaults to 12.",
    )
    minPower: Optional[int] = Field(
        None,
        description='Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30. Defaults to 8.',
    )
    rxsop: Optional[int] = Field(
        None,
        description='The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.',
    )
    validAutoChannels: Optional[List[int]] = Field(
        None,
        description="Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.Defaults to [36, 40, 44, 48, 52, 56, 60, 64, 100, 104, 108, 112, 116, 120, 124, 128, 132, 136, 140, 144, 149, 153, 157, 161, 165].",
    )


class MinBitrateType(Enum):
    band = 'band'
    ssid = 'ssid'


class TwoFourGhzSettings(BaseModel):
    axEnabled: Optional[bool] = Field(
        None,
        description='Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering. Defaults to true.',
    )
    maxPower: Optional[int] = Field(
        None,
        description='Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 30.',
    )
    minBitrate: Optional[float] = Field(
        None,
        description="Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'. Defaults to 11.",
    )
    minPower: Optional[int] = Field(
        None,
        description='Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30. Defaults to 5.',
    )
    rxsop: Optional[int] = Field(
        None,
        description='The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.',
    )
    validAutoChannels: Optional[List[int]] = Field(
        None,
        description="Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'. Defaults to [1, 6, 11].",
    )


class NetworksNetworkIdWirelessRfProfilesPostRequest(BaseModel):
    apBandSettings: Optional[ApBandSettings] = Field(
        None,
        description="Settings that will be enabled if selectionType is set to 'ap'.",
    )
    bandSelectionType: BandSelectionType = Field(
        ...,
        description="Band selection can be set to either 'ssid' or 'ap'. This param is required on creation.",
    )
    clientBalancingEnabled: Optional[bool] = Field(
        None,
        description='Steers client to best available access point. Can be either true or false. Defaults to true.',
    )
    fiveGhzSettings: Optional[FiveGhzSettings] = Field(
        None, description='Settings related to 5Ghz band'
    )
    minBitrateType: Optional[MinBitrateType] = Field(
        None,
        description="Minimum bitrate can be set to either 'band' or 'ssid'. Defaults to band.",
    )
    name: str = Field(
        ...,
        description='The name of the new profile. Must be unique. This param is required on creation.',
    )
    twoFourGhzSettings: Optional[TwoFourGhzSettings] = Field(
        None, description='Settings related to 2.4Ghz band'
    )


class NetworksNetworkIdWirelessRfProfilesPostResponse(BaseModel):
    pass


class NetworksNetworkIdWirelessRfProfilesRfProfileIdGetResponse(BaseModel):
    pass


class ApBandSettings1(BaseModel):
    bandOperationMode: Optional[BandOperationMode] = Field(
        None, description="Choice between 'dual', '2.4ghz' or '5ghz'."
    )
    bandSteeringEnabled: Optional[bool] = Field(
        None,
        description='Steers client to most open band. Can be either true or false.',
    )


class FiveGhzSettings1(BaseModel):
    channelWidth: Optional[str] = Field(
        None,
        description="Sets channel width (MHz) for 5Ghz band. Can be one of 'auto', '20', '40' or '80'.",
    )
    maxPower: Optional[int] = Field(
        None,
        description='Sets max power (dBm) of 5Ghz band. Can be integer between 2 and 30.',
    )
    minBitrate: Optional[int] = Field(
        None,
        description="Sets min bitrate (Mbps) of 5Ghz band. Can be one of '6', '9', '12', '18', '24', '36', '48' or '54'.",
    )
    minPower: Optional[int] = Field(
        None,
        description='Sets min power (dBm) of 5Ghz band. Can be integer between 2 and 30.',
    )
    rxsop: Optional[int] = Field(
        None,
        description='The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.',
    )
    validAutoChannels: Optional[List[int]] = Field(
        None,
        description="Sets valid auto channels for 5Ghz band. Can be one of '36', '40', '44', '48', '52', '56', '60', '64', '100', '104', '108', '112', '116', '120', '124', '128', '132', '136', '140', '144', '149', '153', '157', '161' or '165'.",
    )


class TwoFourGhzSettings1(BaseModel):
    axEnabled: Optional[bool] = Field(
        None,
        description='Determines whether ax radio on 2.4Ghz band is on or off. Can be either true or false. If false, we highly recommend disabling band steering.',
    )
    maxPower: Optional[int] = Field(
        None,
        description='Sets max power (dBm) of 2.4Ghz band. Can be integer between 2 and 30.',
    )
    minBitrate: Optional[float] = Field(
        None,
        description="Sets min bitrate (Mbps) of 2.4Ghz band. Can be one of '1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54'.",
    )
    minPower: Optional[int] = Field(
        None,
        description='Sets min power (dBm) of 2.4Ghz band. Can be integer between 2 and 30.',
    )
    rxsop: Optional[int] = Field(
        None,
        description='The RX-SOP level controls the sensitivity of the radio. It is strongly recommended to use RX-SOP only after consulting a wireless expert. RX-SOP can be configured in the range of -65 to -95 (dBm). A value of null will reset this to the default.',
    )
    validAutoChannels: Optional[List[int]] = Field(
        None,
        description="Sets valid auto channels for 2.4Ghz band. Can be one of '1', '6' or '11'.",
    )


class NetworksNetworkIdWirelessRfProfilesRfProfileIdPutRequest(BaseModel):
    apBandSettings: Optional[ApBandSettings1] = Field(
        None,
        description="Settings that will be enabled if selectionType is set to 'ap'.",
    )
    bandSelectionType: Optional[BandSelectionType] = Field(
        None, description="Band selection can be set to either 'ssid' or 'ap'."
    )
    clientBalancingEnabled: Optional[bool] = Field(
        None,
        description='Steers client to best available access point. Can be either true or false.',
    )
    fiveGhzSettings: Optional[FiveGhzSettings1] = Field(
        None, description='Settings related to 5Ghz band'
    )
    minBitrateType: Optional[MinBitrateType] = Field(
        None, description="Minimum bitrate can be set to either 'band' or 'ssid'."
    )
    name: Optional[str] = Field(
        None, description='The name of the new profile. Must be unique.'
    )
    twoFourGhzSettings: Optional[TwoFourGhzSettings1] = Field(
        None, description='Settings related to 2.4Ghz band'
    )


class NetworksNetworkIdWirelessRfProfilesRfProfileIdPutResponse(BaseModel):
    pass


class NetworksNetworkIdWirelessSettingsGetResponse(BaseModel):
    pass


class UpgradeStrategy(Enum):
    minimizeClientDowntime = 'minimizeClientDowntime'
    minimizeUpgradeTime = 'minimizeUpgradeTime'


class NetworksNetworkIdWirelessSettingsPutRequest(BaseModel):
    ipv6BridgeEnabled: Optional[bool] = Field(
        None,
        description='Toggle for enabling or disabling IPv6 bridging in a network (Note: if enabled, SSIDs must also be configured to use bridge mode)',
    )
    ledLightsOn: Optional[bool] = Field(
        None,
        description='Toggle for enabling or disabling LED lights on all APs in the network (making them run dark)',
    )
    locationAnalyticsEnabled: Optional[bool] = Field(
        None,
        description='Toggle for enabling or disabling location analytics for your network',
    )
    meshingEnabled: Optional[bool] = Field(
        None, description='Toggle for enabling or disabling meshing in a network'
    )
    upgradeStrategy: Optional[UpgradeStrategy] = Field(
        None,
        description="The upgrade strategy to apply to the network. Must be one of 'minimizeUpgradeTime' or 'minimizeClientDowntime'. Requires firmware version MR 26.8 or higher'",
    )


class NetworksNetworkIdWirelessSettingsPutResponse(BaseModel):
    pass


class NetworksNetworkIdSmDevicesLockPutRequest(BaseModel):
    ids: Optional[str] = Field(None, description='The ids of the devices to be locked.')
    pin: Optional[int] = Field(
        None,
        description='The pin number for locking macOS devices (a six digit number). Required only for macOS devices.',
    )
    scope: Optional[str] = Field(
        None,
        description='The scope (one of all, none, withAny, withAll, withoutAny, or withoutAll) and a set of tags of the devices to be wiped.',
    )
    serials: Optional[str] = Field(
        None, description='The serials of the devices to be locked.'
    )
    wifiMacs: Optional[str] = Field(
        None, description='The wifiMacs of the devices to be locked.'
    )


class NetworksNetworkIdSmDevicesLockPutResponse(BaseModel):
    pass


class NetworksNetworkIdSmIdConnectivityGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmIdDesktopLogsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmIdDeviceCommandLogsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class NetworksNetworkIdSmIdPerformanceHistoryGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdGetResponse(BaseModel):
    pass


class Status1(Enum):
    completed = 'completed'
    failed = 'failed'
    pending = 'pending'


class OrganizationsOrganizationIdActionBatchesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Action(BaseModel):
    body: Optional[Dict[str, Any]] = Field({}, description='The body of the action')
    operation: str = Field(..., description='The operation to be used')
    resource: str = Field(
        ..., description='Unique identifier for the resource to be acted on'
    )


class OrganizationsOrganizationIdActionBatchesPostRequest(BaseModel):
    actions: List[Action] = Field(
        ...,
        description="A set of changes to make as part of this action (<a href='https://developer.cisco.com/meraki/api/#/rest/guides/action-batches/'>more details</a>)",
    )
    confirmed: Optional[bool] = Field(
        None,
        description='Set to true for immediate execution. Set to false if the action should be previewed before executing. This property cannot be unset once it is true. Defaults to false.',
    )
    synchronous: Optional[bool] = Field(
        None,
        description='Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch. Defaults to false.',
    )


class OrganizationsOrganizationIdActionBatchesPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdActionBatchesActionBatchIdPutRequest(BaseModel):
    confirmed: Optional[bool] = Field(
        None,
        description='A boolean representing whether or not the batch has been confirmed. This property cannot be unset once it is true.',
    )
    synchronous: Optional[bool] = Field(
        None,
        description='Set to true to force the batch to run synchronous. There can be at most 20 actions in synchronous batch.',
    )


class OrganizationsOrganizationIdActionBatchesActionBatchIdPutResponse(BaseModel):
    pass


class OrganizationsOrganizationIdAdminsGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class AuthenticationMethod(Enum):
    Cisco_SecureX_Sign_On = 'Cisco SecureX Sign-On'
    Email = 'Email'


class Network(BaseModel):
    access: str = Field(
        ..., description='The privilege of the dashboard administrator on the network'
    )
    id: str = Field(..., description='The network ID')


class OrgAccess(Enum):
    enterprise = 'enterprise'
    full = 'full'
    none = 'none'
    read_only = 'read-only'


class Tag(BaseModel):
    access: str = Field(
        ..., description='The privilege of the dashboard administrator on the tag'
    )
    tag: str = Field(..., description='The name of the tag')


class OrganizationsOrganizationIdAdminsPostRequest(BaseModel):
    authenticationMethod: Optional[AuthenticationMethod] = Field(
        None,
        description="The method of authentication the user will use to sign in to the Meraki dashboard. Can be one of 'Email' or 'Cisco SecureX Sign-On'. The default is Email authentication",
    )
    email: str = Field(
        ...,
        description='The email of the dashboard administrator. This attribute can not be updated.',
    )
    name: str = Field(..., description='The name of the dashboard administrator')
    networks: Optional[List[Network]] = Field(
        None,
        description='The list of networks that the dashboard administrator has privileges on',
    )
    orgAccess: OrgAccess = Field(
        ...,
        description="The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'",
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='The list of tags that the dashboard administrator has privileges on',
    )


class OrganizationsOrganizationIdAdminsPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdAdminsAdminIdPutRequest(BaseModel):
    name: Optional[str] = Field(
        None, description='The name of the dashboard administrator'
    )
    networks: Optional[List[Network]] = Field(
        None,
        description='The list of networks that the dashboard administrator has privileges on',
    )
    orgAccess: Optional[OrgAccess] = Field(
        None,
        description="The privilege of the dashboard administrator on the organization. Can be one of 'full', 'read-only', 'enterprise' or 'none'",
    )
    tags: Optional[List[Tag]] = Field(
        None,
        description='The list of tags that the dashboard administrator has privileges on',
    )


class OrganizationsOrganizationIdAdminsAdminIdPutResponse(BaseModel):
    pass


class OrganizationsOrganizationIdApiRequestsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdApiRequestsOverviewGetResponse(BaseModel):
    pass


class Mode3(Enum):
    addDevices = 'addDevices'
    renew = 'renew'


class License(BaseModel):
    key: str = Field(..., description='The key of the license')
    mode: Optional[Mode3] = Field(
        None,
        description="Either 'renew' or 'addDevices'. 'addDevices' will increase the license limit, while 'renew' will extend the amount of time until expiration. Defaults to 'addDevices'. All licenses must be claimed with the same mode, and at most one renewal can be claimed at a time. This parameter is legacy and does not apply to organizations with per-device licensing enabled.",
    )


class OrganizationsOrganizationIdClaimPostRequest(BaseModel):
    licenses: Optional[List[License]] = Field(
        None, description='The licenses that should be claimed'
    )
    orders: Optional[List[str]] = Field(
        None, description='The numbers of the orders that should be claimed'
    )
    serials: Optional[List[str]] = Field(
        None, description='The serials of the devices that should be claimed'
    )


class OrganizationsOrganizationIdClaimPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdClonePostRequest(BaseModel):
    name: str = Field(..., description='The name of the new organization')


class OrganizationsOrganizationIdClonePostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdConfigTemplatesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdConfigTemplatesConfigTemplateIdSwitchProfilesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdConfigurationChangesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdDeviceStatusesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdDevicesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdInsightMonitoredMediaServersGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdInsightMonitoredMediaServersPostRequest(BaseModel):
    address: str = Field(
        ...,
        description='The IP address (IPv4 only) or hostname of the media server to monitor',
    )
    name: str = Field(..., description='The name of the VoIP provider')


class OrganizationsOrganizationIdInsightMonitoredMediaServersPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdInsightMonitoredMediaServersMonitoredMediaServerIdGetResponse(
    BaseModel
):
    pass


class OrganizationsOrganizationIdInsightMonitoredMediaServersMonitoredMediaServerIdPutRequest(
    BaseModel
):
    address: Optional[str] = Field(
        None,
        description='The IP address (IPv4 only) or hostname of the media server to monitor',
    )
    name: Optional[str] = Field(None, description='The name of the VoIP provider')


class OrganizationsOrganizationIdInsightMonitoredMediaServersMonitoredMediaServerIdPutResponse(
    BaseModel
):
    pass


class OrganizationsOrganizationIdInventoryGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdLicenseStateGetResponse(BaseModel):
    pass


class State(Enum):
    active = 'active'
    expired = 'expired'
    expiring = 'expiring'
    recentlyQueued = 'recentlyQueued'
    unused = 'unused'
    unusedActive = 'unusedActive'


class OrganizationsOrganizationIdLicensesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdLicensesAssignSeatsPostRequest(BaseModel):
    licenseId: str = Field(
        ..., description='The ID of the SM license to assign seats from'
    )
    networkId: str = Field(
        ..., description='The ID of the SM network to assign the seats to'
    )
    seatCount: int = Field(
        ...,
        description='The number of seats to assign to the SM network. Must be less than or equal to the total number of seats of the license',
    )


class OrganizationsOrganizationIdLicensesAssignSeatsPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdLicensesMoveSeatsPostRequest(BaseModel):
    destOrganizationId: str = Field(
        ..., description='The ID of the organization to move the SM seats to'
    )
    licenseId: str = Field(
        ..., description='The ID of the SM license to move the seats from'
    )
    seatCount: int = Field(
        ...,
        description='The number of seats to move to the new organization. Must be less than or equal to the total number of seats of the license',
    )


class OrganizationsOrganizationIdLicensesMoveSeatsPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdLicensesRenewSeatsPostRequest(BaseModel):
    licenseIdToRenew: str = Field(
        ...,
        description='The ID of the SM license to renew. This license must already be assigned to an SM network',
    )
    unusedLicenseId: str = Field(
        ...,
        description="The SM license to use to renew the seats on 'licenseIdToRenew'. This license must have at least as many seats available as there are seats on 'licenseIdToRenew'",
    )


class OrganizationsOrganizationIdLicensesRenewSeatsPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdLicensesLicenseIdGetResponse(BaseModel):
    pass


class OrganizationsOrganizationIdNetworksGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdNetworksPostRequest(BaseModel):
    copyFromNetworkId: Optional[str] = Field(
        None,
        description="The ID of the network to copy configuration from. Other provided parameters will override the copied configuration, except type which must match this network's type exactly.",
    )
    disableMyMerakiCom: Optional[bool] = Field(
        None,
        description="Disables the local device status pages (<a target='_blank' href='http://my.meraki.com/'>my.meraki.com, </a><a target='_blank' href='http://ap.meraki.com/'>ap.meraki.com, </a><a target='_blank' href='http://switch.meraki.com/'>switch.meraki.com, </a><a target='_blank' href='http://wired.meraki.com/'>wired.meraki.com</a>). Optional (defaults to false)",
    )
    disableRemoteStatusPage: Optional[bool] = Field(
        None,
        description="Disables access to the device status page (<a target='_blank'>http://[device's LAN IP])</a>. Optional. Can only be set if disableMyMerakiCom is set to false",
    )
    name: str = Field(..., description='The name of the new network')
    tags: Optional[str] = Field(
        None, description='A space-separated list of tags to be applied to the network'
    )
    timeZone: Optional[str] = Field(
        None,
        description="The timezone of the network. For a list of allowed timezones, please see the 'TZ' column in the table in <a target='_blank' href='https://en.wikipedia.org/wiki/List_of_tz_database_time_zones'>this article.</a>",
    )
    type: str = Field(
        ...,
        description='The type of the new network. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, environmental, or a space-separated list of those for a combined network.',
    )


class OrganizationsOrganizationIdNetworksPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdNetworksCombinePostRequest(BaseModel):
    enrollmentString: Optional[str] = Field(
        None,
        description="A unique identifier which can be used for device enrollment or easy access through the Meraki SM Registration page or the Self Service Portal. Please note that changing this field may cause existing bookmarks to break. All networks that are part of this combined network will have their enrollment string appended by '-network_type'. If left empty, all exisitng enrollment strings will be deleted.",
    )
    name: str = Field(..., description='The name of the combined network')
    networkIds: List[str] = Field(
        ...,
        description='A list of the network IDs that will be combined. If an ID of a combined network is included in this list, the other networks in the list will be grouped into that network',
    )


class OrganizationsOrganizationIdNetworksCombinePostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdOpenapiSpecGetResponse(BaseModel):
    pass


class OrganizationsOrganizationIdSamlRolesGetResponse(RootModel[List[Dict[str, Any]]]):
    root: List[Dict[str, Any]]


class Network2(BaseModel):
    access: str = Field(
        ..., description='The privilege of the SAML administrator on the network'
    )
    id: str = Field(..., description='The network ID')


class Tag2(BaseModel):
    access: str = Field(
        ..., description='The privilege of the SAML administrator on the tag'
    )
    tag: str = Field(..., description='The name of the tag')


class OrganizationsOrganizationIdSamlRolesPostRequest(BaseModel):
    networks: Optional[List[Network2]] = Field(
        None,
        description='The list of networks that the SAML administrator has privileges on',
    )
    orgAccess: str = Field(
        ..., description='The privilege of the SAML administrator on the organization'
    )
    role: str = Field(..., description='The role of the SAML administrator')
    tags: Optional[List[Tag2]] = Field(
        None,
        description='The list of tags that the SAML administrator has privleges on',
    )


class OrganizationsOrganizationIdSamlRolesPostResponse(BaseModel):
    pass


class OrganizationsOrganizationIdSamlRolesSamlRoleIdGetResponse(BaseModel):
    pass


class OrganizationsOrganizationIdSamlRolesSamlRoleIdPutRequest(BaseModel):
    networks: Optional[List[Network2]] = Field(
        None,
        description='The list of networks that the SAML administrator has privileges on',
    )
    orgAccess: Optional[str] = Field(
        None, description='The privilege of the SAML administrator on the organization'
    )
    role: Optional[str] = Field(None, description='The role of the SAML administrator')
    tags: Optional[List[Tag2]] = Field(
        None,
        description='The list of tags that the SAML administrator has privleges on',
    )


class OrganizationsOrganizationIdSamlRolesSamlRoleIdPutResponse(BaseModel):
    pass


class OrganizationsOrganizationIdSecurityIntrusionSettingsGetResponse(BaseModel):
    pass


class WhitelistedRule(BaseModel):
    message: Optional[str] = Field(
        None,
        description='Message is optional and is ignored on a PUT call. It is allowed in order for PUT to be compatible with GET',
    )
    ruleId: str = Field(
        ...,
        description='A rule identifier of the format meraki:intrusion/snort/GID/<gid>/SID/<sid>. gid and sid can be obtained from either https://www.snort.org/rule-docs or as ruleIds from the security events in /organization/[orgId]/securityEvents',
    )


class OrganizationsOrganizationIdSecurityIntrusionSettingsPutRequest(BaseModel):
    whitelistedRules: List[WhitelistedRule] = Field(
        ..., description='Sets a list of specific SNORT signatures to allow'
    )


class OrganizationsOrganizationIdSecurityIntrusionSettingsPutResponse(BaseModel):
    pass


class OrganizationsOrganizationIdSecurityEventsGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdSnmpGetResponse(BaseModel):
    pass


class OrganizationsOrganizationIdThirdPartyVPNPeersGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class IkeVersion(Enum):
    field_1 = '1'
    field_2 = '2'


class IkePrfAlgoEnum(Enum):
    default = 'default'
    prfmd5 = 'prfmd5'
    prfsha1 = 'prfsha1'
    prfsha256 = 'prfsha256'


class IpsecPolicies(BaseModel):
    childAuthAlgo: Optional[List[str]] = Field(
        None,
        description="This is the authentication algorithms to be used in Phase 2. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'",
    )
    childCipherAlgo: Optional[List[str]] = Field(
        None,
        description="This is the cipher algorithms to be used in Phase 2. The value should be an array with one or more of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des', 'null'",
    )
    childLifetime: Optional[int] = Field(
        None, description='The lifetime of the Phase 2 SA in seconds.'
    )
    childPfsGroup: Optional[List[str]] = Field(
        None,
        description="This is the Diffie-Hellman group to be used for Perfect Forward Secrecy in Phase 2. The value should be an array with one of the following values: 'disabled','group14', 'group5', 'group2', 'group1'",
    )
    ikeAuthAlgo: Optional[List[str]] = Field(
        None,
        description="This is the authentication algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'sha256', 'sha1', 'md5'",
    )
    ikeCipherAlgo: Optional[List[str]] = Field(
        None,
        description="This is the cipher algorithm to be used in Phase 1. The value should be an array with one of the following algorithms: 'aes256', 'aes192', 'aes128', 'tripledes', 'des'",
    )
    ikeDiffieHellmanGroup: Optional[List[str]] = Field(
        None,
        description="This is the Diffie-Hellman group to be used in Phase 1. The value should be an array with one of the following algorithms: 'group14', 'group5', 'group2', 'group1'",
    )
    ikeLifetime: Optional[int] = Field(
        None, description='The lifetime of the Phase 1 SA in seconds.'
    )
    ikePrfAlgo: Optional[List[IkePrfAlgoEnum]] = Field(
        None,
        description="[optional] This is the pseudo-random function to be used in IKE_SA. The value should be an array with one of the following algorithms: 'prfsha256', 'prfsha1', 'prfmd5', 'default'. The 'default' option can be used to default to the Authentication algorithm.",
    )


class Peer(BaseModel):
    ikeVersion: Optional[IkeVersion] = Field(
        '1',
        description="[optional] The IKE version to be used for the IPsec VPN peer configuration. Defaults to '1' when omitted.",
    )
    ipsecPolicies: Optional[IpsecPolicies] = Field(
        None,
        description='Custom IPSec policies for the VPN peer. If not included and a preset has not been chosen, the default preset for IPSec policies will be used.',
    )
    ipsecPoliciesPreset: Optional[str] = Field(
        None,
        description="One of the following available presets: 'default', 'aws', 'azure'. If this is provided, the 'ipsecPolicies' parameter is ignored.",
    )
    name: str = Field(..., description='The name of the VPN peer')
    networkTags: Optional[List[str]] = Field(
        None,
        description="A list of network tags that will connect with this peer. Use ['all'] for all networks. Use ['none'] for no networks. If not included, the default is ['all'].",
    )
    privateSubnets: List[str] = Field(
        ..., description='The list of the private subnets of the VPN peer'
    )
    publicIp: str = Field(..., description='The public IP of the VPN peer')
    remoteId: Optional[str] = Field(
        None,
        description='[optional] The remote ID is used to identify the connecting VPN peer. This can either be a valid IPv4 Address, FQDN or User FQDN.',
    )
    secret: str = Field(..., description='The shared secret with the VPN peer')


class OrganizationsOrganizationIdThirdPartyVPNPeersPutRequest(BaseModel):
    peers: List[Peer] = Field(..., description='The list of VPN peers')


class OrganizationsOrganizationIdThirdPartyVPNPeersPutResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Uplink5(Enum):
    cellular = 'cellular'
    wan1 = 'wan1'
    wan2 = 'wan2'


class OrganizationsOrganizationIdUplinksLossAndLatencyGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class OrganizationsOrganizationIdVpnFirewallRulesGetResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]


class Protocol9(Enum):
    any = 'any'
    icmp = 'icmp'
    icmp6 = 'icmp6'
    tcp = 'tcp'
    udp = 'udp'


class Rule9(BaseModel):
    comment: Optional[str] = Field(
        None, description='Description of the rule (optional)'
    )
    destCidr: str = Field(
        ...,
        description="Comma-separated list of destination IP address(es) (in IP or CIDR notation) or 'any' (FQDN not supported)",
    )
    destPort: Optional[str] = Field(
        None,
        description="Comma-separated list of destination port(s) (integer in the range 1-65535), or 'any'",
    )
    policy: Policy4 = Field(
        ..., description="'allow' or 'deny' traffic specified by this rule"
    )
    protocol: Protocol9 = Field(
        ...,
        description="The type of protocol (must be 'tcp', 'udp', 'icmp', 'icmp6' or 'any')",
    )
    srcCidr: str = Field(
        ...,
        description="Comma-separated list of source IP address(es) (in IP or CIDR notation), or 'any' (FQDN not supported)",
    )
    srcPort: Optional[str] = Field(
        None,
        description="Comma-separated list of source port(s) (integer in the range 1-65535), or 'any'",
    )
    syslogEnabled: Optional[bool] = Field(
        None,
        description='Log this rule to syslog (true or false, boolean value) - only applicable if a syslog has been configured (optional)',
    )


class OrganizationsOrganizationIdVpnFirewallRulesPutRequest(BaseModel):
    rules: Optional[List[Rule9]] = Field(
        None,
        description='An ordered array of the firewall rules (not including the default rule)',
    )
    syslogDefaultRule: Optional[bool] = Field(
        None,
        description="Log the special default rule (boolean value - enable only if you've configured a syslog server) (optional)",
    )


class OrganizationsOrganizationIdVpnFirewallRulesPutResponse(
    RootModel[List[Dict[str, Any]]]
):
    root: List[Dict[str, Any]]
